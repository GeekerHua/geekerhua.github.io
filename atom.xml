<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekerHua的Blog</title>
  <subtitle>爱生活，爱自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.geekerhua.com/"/>
  <updated>2017-06-12T04:53:40.000Z</updated>
  <id>blog.geekerhua.com/</id>
  
  <author>
    <name>GeekerHua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python常量的正确写法</title>
    <link href="blog.geekerhua.com/2017/06/12/Python_const/"/>
    <id>blog.geekerhua.com/2017/06/12/Python_const/</id>
    <published>2017-06-12T04:45:26.000Z</published>
    <updated>2017-06-12T04:53:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Python内建的命名空间是支持小部分常量的，例如True、False、None等，但Python默认是没有提供直接定义常量的方法，因此要想实现常量的功能需要人为实现。一般有两种方法</p>
</blockquote>
<h3 id="一：通过明明风格提醒使用者该变量代表的意义为常量"><a href="#一：通过明明风格提醒使用者该变量代表的意义为常量" class="headerlink" title="一：通过明明风格提醒使用者该变量代表的意义为常量"></a>一：通过明明风格提醒使用者该变量代表的意义为常量</h3><blockquote>
<p>如长两名所有字母大写,使用下划线连接各个单词，<code>MAX_OVERFLOW</code>、<code>TOTAL</code>。这是一种约定俗称的风格，对应的值仍然可以改变。</p>
</blockquote>
<h3 id="二：通过自定义的类实现常量功能。"><a href="#二：通过自定义的类实现常量功能。" class="headerlink" title="二：通过自定义的类实现常量功能。"></a>二：通过自定义的类实现常量功能。</h3><blockquote>
<p>要求符合“命名全部大写”和“值一旦绑定便不可再修改”两个条件。下面是一种较为常见的解决方法，它通过对常量对应的值进行修改时或者命名不符合规范时抛出异常来满足以上常量的两个条件。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">_const</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConstError</span><span class="params">(TypeError)</span>:</span> <span class="keyword">pass</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConstCaseError</span><span class="params">(ConstError)</span>:</span> <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.__dict__.has_key(name):</div><div class="line">            <span class="keyword">raise</span> self.ConstError, <span class="string">"Can't change const.%s"</span> % name</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.isupper():</div><div class="line">            <span class="keyword">raise</span> self.ConstCaseError, <span class="string">'const name "%s" is not all uppercase'</span> % name</div><div class="line">        self.__dict__[name] = value</div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">sys.modules[__name__] = _const()</div><div class="line"></div><div class="line"><span class="keyword">import</span> constant</div><div class="line"><span class="comment"># 在这之后定义常量</span></div><div class="line">constant.A = <span class="string">'a'</span></div></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>如此之后，导入这个模块，在这个模块中定义常量，建议将所有常量都定义到这个模块中，方便统一管理。使用的时候，</p>
<ul>
<li>如果对已经定义到常量进行修改会报<code>ConstError</code>错误；</li>
<li>如果定义的常量不是全大写，会报<code>ConstCaseError</code>错误。</li>
</ul>
<p>例如模块名为constant.py，在其他文件中使用方法为：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> constant</div><div class="line">constant.A = <span class="string">'a'</span></div><div class="line">constant.B_Play = <span class="string">'xxx'</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python内建的命名空间是支持小部分常量的，例如True、False、None等，但Python默认是没有提供直接定义常量的方法，因此要想实现常量的功能需要人为实现。一般有两种方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一：通过明明
    
    </summary>
    
      <category term="Python" scheme="blog.geekerhua.com/categories/Python/"/>
    
    
      <category term="Python" scheme="blog.geekerhua.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Alfred手记一：简化nc传输操作</title>
    <link href="blog.geekerhua.com/2017/05/12/alfred1-nc/"/>
    <id>blog.geekerhua.com/2017/05/12/alfred1-nc/</id>
    <published>2017-05-12T04:48:00.000Z</published>
    <updated>2017-06-12T04:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>nc是什么，nc是一个简单传输协议。nc的具体使用在文章后边会做详细的介绍。简单说就是，通过nc能够在局域网中传输文件，由于是基于TCP协议，无论是速度还是稳定性都很可靠，除此之外还能进行聊天。如果说缺点，那就是传输文件时需要在命令行指定端口号，而且接收方还要自己输入文件名。</p>
<p>由于前段时间经常使用nc，所以突发奇想，想把nc服务写到Alfred的workflow中，从而简化操作。虽然对于mac来说，airdrop要比nc好用多了，但通过这个例子，还是能学到很多关于workflow开发的提示，近日后开发更复杂强大的workflow带来些许帮助。</p>
<h2 id="最终效果。"><a href="#最终效果。" class="headerlink" title="最终效果。"></a>最终效果。</h2><h3 id="文件发送"><a href="#文件发送" class="headerlink" title="文件发送"></a>文件发送</h3><p>作为服务端，nc的命令为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ nc <span class="_">-l</span> `port` &lt; `document`</div></pre></td></tr></table></figure>
<p>只需要指定port端口号，和文件就行。既然如此，我们大可以借助Alfred自带的文件搜索功能，调出nc发送功能。这要比直接去Finder中进行查找文件，或者在终端中输入常常的文件路径要高效的多。</p>
<p><img src="http://img.geekerhua.com/blog/alfred1/14898397730412.jpg" alt="14898397730412"><br><img src="http://img.geekerhua.com/blog/alfred1/14898397975568.jpg" alt="14898397975568"><br><img src="http://img.geekerhua.com/blog/alfred1/14898398228729.jpg" alt="14898398228729"></p>
<p>发送一共分三步：</p>
<ul>
<li>用Alfred找到需要发送的文件</li>
<li>按下<code>Ctrl</code>键，进入文件操作，选择ncsend命令</li>
<li>输入端口号，按下回车。<br>即启动一个终端执行发送监听模式，等待客户端进行接收。与此同时，屏幕上会用大字显示出本机的局域网ip和刚才输入的端口号，方便客户端使用。<br><img src="http://img.geekerhua.com/blog/alfred1/14898400344094.jpg" alt="14898400344094"><h3 id="文件接收"><a href="#文件接收" class="headerlink" title="文件接收"></a>文件接收</h3>对于文件的接收，nc的命令为：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ nc -n `ip` `port` &gt; `document`</div></pre></td></tr></table></figure>
<p>可以看到不仅不要客户端的端口号，还需要客户端的ip。刚才的服务端操作已经实现了发送，并把内网ip和端口号显示在屏幕中了。客户端只需要借助workflow执行接收命令即可。<br><img src="http://img.geekerhua.com/blog/alfred1/14898402129318.jpg" alt="14898402129318"><br><img src="http://img.geekerhua.com/blog/alfred1/14898402642075.jpg" alt="14898402642075"></p>
<p>接收一共两步：</p>
<ul>
<li>调出nc，并输入ip和端口号，使用空格分隔，按下回车</li>
<li>提示输入接收文件名，按下回车即可接收，默认保存到<code>~/Downloads</code>文件夹下。</li>
</ul>
<p>由此接收工作也完成了。整体来说对命令的简化并不是很明显，但可以以此来简单了解下workflow的工作原理。</p>
<h2 id="nc——netcat"><a href="#nc——netcat" class="headerlink" title="nc——netcat"></a>nc——netcat</h2><ul>
<li>server: nc -l <code>port</code> &lt; <code>document</code></li>
<li>client: nc -n <code>ip</code> <code>port</code> &gt; <code>document</code></li>
</ul>
<h2 id="用nc聊天"><a href="#用nc聊天" class="headerlink" title="用nc聊天"></a>用nc聊天</h2><ul>
<li>server: nc -l 10000</li>
<li>nc <code>ip</code> 10000</li>
</ul>
<hr>
<h2 id="nc-netCat-常用命令"><a href="#nc-netCat-常用命令" class="headerlink" title="nc (netCat)常用命令"></a>nc (netCat)常用命令</h2><p><code>nc -l [-u] 9090</code>: 在9090端口开启tcp服务器<br><code>[-v] [-u] 127.0.0.1 9090</code>: 连接本地ip的9090端口tcp服务器</p>
<p><code>-l</code>: 启动监听, 启动服务器必须<br><code>-v</code>: 显示连接进度<br><code>-u</code>: 使用udp通信, 默认是tcp, 使用udp连接可以保持一直监听状态<br><code>-w2</code>: 设置超时2秒<br><code>-z</code>: 检测端口</p>
<h3 id="tcp聊天"><a href="#tcp聊天" class="headerlink" title="tcp聊天"></a>tcp聊天</h3><p><code>nc -l 9090</code>: tcp监听9090端口<br><code>nc 127.0.0.1 9090</code>: tcp连接9090端口<br>可以用重定向 ‘&lt;’/‘&gt;’, 指定传输内容, 只能响应一个客户端, 客户端断开, 服务器端也会断开</p>
<h3 id="udp聊天"><a href="#udp聊天" class="headerlink" title="udp聊天"></a>udp聊天</h3><p><code>nc -lu 9090</code>: udp监听9090端口<br><code>nc -u 127.0.0.1 9090</code>: udp连接9090端口<br>可以用重定向 ‘&lt;’/‘&gt;’, 指定传输内容, 只能响应一个客户端, 客户端断开, 服务器端不会断开</p>
<h3 id="检查端口"><a href="#检查端口" class="headerlink" title="检查端口"></a>检查端口</h3><p><code>nc -z 127.0.0.1 1-100</code>: 查看指定ip tcp 连接 的 1-100端口<br><code>nc -z -u 127.0.0.1 1-100</code>: 查看指定ip udp 连接 的 1-100端口</p>
<h3 id="远程传输文件"><a href="#远程传输文件" class="headerlink" title="远程传输文件"></a>远程传输文件</h3><p><code>nc -l 9090 &gt; test.tmp</code>: 监听 9090 端口 并把信息输出到指定文件<br><code>nc 127.0.0.1 9090 &lt; test.tmp</code>: 连接服务, 并把文件输出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nc是什么，nc是一个简单传输协议。nc的具体使用在文章后边会做详细的介绍。简单说就是，通过nc能够在局域网中传输文件，由于是基于TCP协议，无论是速度还是稳定性都很可靠，除此之外还能进行聊天。如果说缺点，那就是传输文件时需要在命令行指定端口号，而且接收方还要自己输入文件名
    
    </summary>
    
      <category term="工具" scheme="blog.geekerhua.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="效率" scheme="blog.geekerhua.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="Alfred" scheme="blog.geekerhua.com/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>我的2016数字化生活</title>
    <link href="blog.geekerhua.com/2017/03/16/2016-digital-life/"/>
    <id>blog.geekerhua.com/2017/03/16/2016-digital-life/</id>
    <published>2017-03-16T10:37:42.000Z</published>
    <updated>2017-03-16T10:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年已经过去2个多月了，到现在才开始整理我的2016年数字化生活，这也是收到了<code>少数派</code>的数字化生活文章评选活动的触发。阅读了很多篇精选的数字化生活指南，很多是经典的，很多是新奇的。也有很多是碎碎的试探性的。我感觉，是时候整理我的数字化生活了，因为我的数字化生活同样很精彩。</p>
<p>数字化生活，我们已经离不开手机📱和电脑💻等数字化设备了 ，当然我还有kindle以及ipad、🎧等设备，数字化生活离不开数字化设备，以下是我的数字化设备。</p>
<h2 id="数字化设备"><a href="#数字化设备" class="headerlink" title="数字化设备"></a>数字化设备</h2><h3 id="MacBook-Pro💻"><a href="#MacBook-Pro💻" class="headerlink" title="MacBook Pro💻"></a>MacBook Pro💻</h3><p><img src="http://img.geekerhua.com/blog/2016-digital-life/14896602355720.jpg" alt=""><br>对于一个程序员来说，最好的生产力工具无非就是MacBook Pro了，相对于15寸的大屏，13寸的屏幕无疑是更具有吸引力的，方便携带、轻薄、高清的屏幕、强劲的性能，更重要的是那优美的mac OS系统以及类Unix特性。有人说屏幕太小了，但对于一个笔记本来说，多大的屏幕够用呢？外接一个显示器🖥，想要多大就多大，甚至你可以接两个。不同于Windows系统只有一个桌面，Mac拥有多个桌面，借助于圆润的触摸板，可以很轻松的在多个桌面间进行切换，大大减轻了对显示器🖥的依赖。</p>
<p>拥有了MacBook Pro，就拥有了以下好处：</p>
<ul>
<li>一台运行快速的笔记本；</li>
<li>高清显示屏，看的再久眼👁也不会那么累；</li>
<li>可以原生运行Linux程序的类Unix系统，开发环境不愁人；</li>
<li>一套能够高效运行的系统；</li>
<li>从此告别关机，开机的等待；</li>
<li>告别各种全家桶及病毒的侵扰；</li>
<li>原理没有意义的游戏，将时间用在有意义的事情上。</li>
</ul>
<h4 id="Alfred-3——我真的离不开"><a href="#Alfred-3——我真的离不开" class="headerlink" title="Alfred 3——我真的离不开"></a>Alfred 3——我真的离不开</h4><p><img src="http://img.geekerhua.com/blog/2016-digital-life/14896601762643.jpg" alt=""><br>Mac下的效率神器，没有之一。<br>对一个热爱折腾的人来说，Alfred真的是最好的礼物🎁，如果再会写点脚本，那真的就是把这款神器的能力发挥到最大化，目前Alfred支持bash、zsh、python、php、ruby、Applescript、JavaScript语言。<br>开发Alfred的workflow是幸福激动的，特别是看到自己能够写出一个自己能够使用的并且能够提高效率，自动完成计划化工作的程序，真的是很激动很幸福的一件事。<br>到目前为止为Alfred开发了5个workflow，分别是large(显示大号文字)，git(git仓库管理)，hexo(hexo博客管理)，nc(懒人nc传输)，gitbook(gitbook管理），Minimal-TODO(极简todo工具)。稍后会有一个关于Alfred的专题，会详细介绍这几个workflow的开发过程。</p>
<h4 id="Übersicht——美哭了的桌面"><a href="#Übersicht——美哭了的桌面" class="headerlink" title="Übersicht——美哭了的桌面"></a>Übersicht——美哭了的桌面</h4><p><img src="http://img.geekerhua.com/blog/2016-digital-life/14895790542943.jpg" alt=""><br><img src="http://img.geekerhua.com/blog/2016-digital-life/14895790722245.jpg" alt=""><br><img src="http://img.geekerhua.com/blog/2016-digital-life/14895790650809.jpg" alt=""><br>Übersicht是一个能够在桌面上显示coffee脚本的软件，借助强大的coffee脚本，能够实现很多意向不到的功能，且界面简洁美观，大部分半透明的白色。</p>
<p>借助于Alfred的工作流，更是能将Übersicht的功能发挥的淋漓尽致，只不过它只支持coffee语言。</p>
<h4 id="Reeder——优美的RSS"><a href="#Reeder——优美的RSS" class="headerlink" title="Reeder——优美的RSS"></a>Reeder——优美的RSS</h4><p>数字化生活怎么能离开信息的阅读，只有自己精挑细选的内容来源，才是最值得预读的。RSS在这方面具有绝对的优势，借助Reeder这款软件和Inoreader的免费服务，能够将RSS的阅读体验最大化，Inoreader可以集中管理订阅源，并进行文件夹📂分类，同时能够记录阅读记录📝与星标收藏。而Reeder具有Mac和iOS双平台，操作流畅，借助Inoreader能够实现完全同步，还可以离线缓存阅读，简直就是神器。<br><img src="http://img.geekerhua.com/blog/2016-digital-life/14895794741885.jpg" alt=""></p>
<p>手机版长这个样子。<br><img src="http://img.geekerhua.com/blog/2016-digital-life/IMG_3478.png" alt="IMG_3478"></p>
<h4 id="Day-One记录美好"><a href="#Day-One记录美好" class="headerlink" title="Day One记录美好"></a>Day One记录美好</h4><p>Day One无疑是apple平台下最好用的日记软件。高颜值，支持markdown成了书写✍️利器。从另一个方面讲，Day One的排版特别适合写微信公众号文章，写好了，一复制，一篇文章就OK了，连排版都省了，特别方便。<br><img src="http://img.geekerhua.com/blog/2016-digital-life/14895809605099.jpg" alt=""></p>
<blockquote>
<p>除此之外，还有一大票应用，就不一一介绍了，包括但不局限于Mweb,Ulysses,奇妙清单,BetterTouchTool等。</p>
</blockquote>
<h3 id="iPhone-5s📱"><a href="#iPhone-5s📱" class="headerlink" title="iPhone 5s📱"></a>iPhone 5s📱</h3><p><img src="http://img.geekerhua.com/blog/2016-digital-life/iPhone.jpg" alt="iPhone"></p>
<p>做为后PC💻时代的核心，手机📱至关重要，它占据了数字化生活相当一部分的比重。相对于百家争鸣的Android收集，iPhone无疑更具有竞争力。一部iPhone5s，服役2年了，除了电池🔋不耐用，其它地方和新的没啥区别，换一个钢化玻璃膜，那颜值，简直美哭。</p>
<h3 id="iPad-Air"><a href="#iPad-Air" class="headerlink" title="iPad Air"></a>iPad Air</h3><p>作为主打娱乐的产物，无疑被我冷落了。这台iPad伴随我三年了，还好仅仅把它当做一台娱乐设备，没有太多的依赖，16G内存勉强够用。没事看看视频，有事儿了看看pdf文件，也挺好。</p>
<h3 id="LG-21-9显示器🖥"><a href="#LG-21-9显示器🖥" class="headerlink" title="LG 21:9显示器🖥"></a>LG 21:9显示器🖥</h3><p><img src="http://img.geekerhua.com/blog/2016-digital-life/IMG_3480.jpg" alt="IMG_3480"><br>对于程序员来说，多大的显示器🖥都不够用，不方便扩展两台显示器🖥，那只好选一个能够以一敌二的显示器🖥了，LG无疑是最佳选择。25寸的尺寸对于一般比例的显示器🖥来说可能很大，但在21:9的宽高比中，却显示扁平狭长，整体高度与19寸显示器🖥并无差异，但却更加宽了，宽到能够左右分屏完整显示两个网页，对一个开发来说，这无疑很是方便，再配合笔记本💻自带的屏幕，上边一个宽屏，下边一个笔记本💻，相当于三个显示器🖥，还有更爽的吗？</p>
<h3 id="kindle📚"><a href="#kindle📚" class="headerlink" title="kindle📚"></a>kindle📚</h3><p>专业的阅读神器，神在提供无法匹敌的纯净的阅读环境。使用kindle看书，能够排除其它一切干扰，不会被是不是的消息所打断，也不会因为好奇去点击尝试其它功能，除了看书，它几乎什么都做不了。<br>对于一个程序员来说，我需要学习，而且可能是终生，而看书做为一个古老而又充满生命力的途径，kindle无疑能够将读书发扬光大。但kindle不适合看程序相关的书籍，因为屏幕较窄，只有黑边两色，看代码费神，用来看其它书籍很是不错，配套资源也是非常丰富。</p>
<h3 id="魅族Ep51🎧"><a href="#魅族Ep51🎧" class="headerlink" title="魅族Ep51🎧"></a>魅族Ep51🎧</h3><p><img src="http://img.geekerhua.com/blog/2016-digital-life/ep51.jpg" alt="ep51"><br>颜值很高的一款蓝牙耳机，虽然咱没有魅族手机，但这款耳机确实特别喜爱，当初想买一个耳机，无奈官网没货，跑到实体店刷卡买了一个。<br>因为是蓝牙的，所以听歌很方便，不用担心线的问题，跑步的时候也可以无忧无虑的使用。缺点就是与iPhone一同使用的时候，中间的按键只能起到开机、关机、蓝牙匹配、暂停、播放的功能，并不能实现下一首、重播、上一首等功能。不过这也不太重要不是吗。</p>
<h3 id="Moov⌚️——想爱上运动🏃吗"><a href="#Moov⌚️——想爱上运动🏃吗" class="headerlink" title="Moov⌚️——想爱上运动🏃吗"></a>Moov⌚️——想爱上运动🏃吗</h3><p><img src="http://img.geekerhua.com/blog/2016-digital-life/14896594615143.jpg" alt=""><br>Moov手环进入中国了，相比与国内的WeCoach，Moov无疑做的更好，虽然到现在为止也没用上拳击功能，但真心很期待，过阵子不太忙了，在买一只，两只手各带一只，就可以打拳击了。<br>Moov目前支持以下运动</p>
<ul>
<li>游泳，能够准确的记录游泳的距离、划频等参数，还能分辨出泳姿。</li>
<li>有氧拳击，支持一个手环和两个手环，当然两个手环是最好的，使用起来就和打游戏一样，有模有样，感觉超级棒。</li>
<li>跑步，支持效率跑、速度耐力跑、健走、冲刺跑、自由跑共五种模式，大部分都可以在跑步机上进行。</li>
<li>骑行，支持室内骑行和室外骑行。</li>
<li>七分钟运动，简单的七分钟运动，关键在于能够分析判断出是否完成了某个动作，以及是否标准，再也不用担心偷懒了。</li>
</ul>
<p>共五种运动，根据佩戴位置不同能够检测运动状况，并通过耳机事实提醒，鼓励，针对不规范动作进行纠正。初次之外还有睡眠检测功能。佩戴舒适，关键是电池使用寿命长达6个月，带上就不用操心了。每一项运动都分很多级别，低级别进行解锁才能使用高级别。</p>
<blockquote>
<p>2016年过去了，伴随着众多心爱的设备，渡过了一整年，愿2017年更加有意义。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年已经过去2个多月了，到现在才开始整理我的2016年数字化生活，这也是收到了&lt;code&gt;少数派&lt;/code&gt;的数字化生活文章评选活动的触发。阅读了很多篇精选的数字化生活指南，很多是经典的，很多是新奇的。也有很多是碎碎的试探性的。我感觉，是时候整理我的数字化生活了，因
    
    </summary>
    
      <category term="成长" scheme="blog.geekerhua.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="成长" scheme="blog.geekerhua.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Alfred手记五：与Übersicht一同构建极简TodoList</title>
    <link href="blog.geekerhua.com/2017/03/16/alfred5-todolist/"/>
    <id>blog.geekerhua.com/2017/03/16/alfred5-todolist/</id>
    <published>2017-03-16T10:00:19.000Z</published>
    <updated>2017-06-12T04:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>先来秀一张布置好的桌面图，怎么样是不是很清爽简约啊！<br><img src="http://img.geekerhua.com/blog/alfred5/2017-03-15%2019_00_17.gif" alt="2017-03-15 19_00_17"></p>
<h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><ul>
<li>Alfred <a href="https://www.alfredapp.com" target="_blank" rel="external">官网链接</a><ul>
<li>Minimal-TODO <a href="https://github.com/GeekerHua/alfred-Minimal-TODO/releases" target="_blank" rel="external">github下载</a></li>
</ul>
</li>
<li>Übersicht <a href="http://tracesof.net/uebersicht/" target="_blank" rel="external">官网链接</a><ul>
<li>插件商店  <a href="http://tracesof.net/uebersicht-widgets/" target="_blank" rel="external">点击访问</a></li>
<li>TODO <a href="https://raw.githubusercontent.com/illuminati945/ToDo/master/ToDo.widget.zip" target="_blank" rel="external">点击下载</a></li>
</ul>
</li>
</ul>
<h2 id="急速教程"><a href="#急速教程" class="headerlink" title="急速教程"></a>急速教程</h2><ul>
<li>用到两款软件，<code>Alfred</code>和<code>Übersicht</code>。</li>
<li>外加两个插件，<code>Übersicht</code>下的<code>ToDo</code>和Alfred下的<code>Minimal-TODO</code>。</li>
</ul>
<blockquote>
<p>tips: 要想运行<code>Minimal-TODO</code>，需要拥有<code>Powerpack</code>功能，付费还是使用破解版本，随你咯。</p>
</blockquote>
<p>本身两个插件是独立运行的，没有任何关联，但两者都是操作一个txt文本，该文本文件每一行为一个TODO任务，使用<code>-</code>开头代表任务以完成。</p>
<ul>
<li>在<code>Übersicht</code>的桌面插件上会已灰色文字显示，并添加中划线。</li>
<li>在<code>Alfred</code>的插件中，可以对该文本进行操作，获取所有TODO，添加TODO，删除TODO，标记为完成状态，重置为未完成状态等操作。<br><img src="http://img.geekerhua.com/blog/alfred5/14896526072534.jpg" alt=""><br><img src="http://img.geekerhua.com/blog/alfred5/14896526569327.jpg" alt=""><br><img src="http://img.geekerhua.com/blog/alfred5/14896527156078.jpg" alt=""></li>
</ul>
<p><code>Minimal-TODO</code>是一个极简todo list工具，todo任务文件放在指定的路径中，例如”~/Documents/Alfred/todos/todo.txt”。</p>
<p>使用“todo”来触发程序，默认会列出添加的todo，“-”开头意味着已经完成的todo。<br>可以使用的命令列表如下：</p>
<ul>
<li>“todo -c”  –&gt; clear all done功能，清除所以已完成项；</li>
<li>“todo -a”  –&gt; 添加任务，支持一次添加多个，使用空格分割；</li>
<li>“todo -r”  –&gt; reset all 重置所有任务为未完成状态。</li>
</ul>
<h3 id="必要设置"><a href="#必要设置" class="headerlink" title="必要设置"></a>必要设置</h3><h4 id="1-ToDo插件的列表路径，无默认路径"><a href="#1-ToDo插件的列表路径，无默认路径" class="headerlink" title="1.  ToDo插件的列表路径，无默认路径"></a>1.  <code>ToDo</code>插件的列表路径，无默认路径</h4><p><code>Übersicht</code>的<code>ToDo</code>插件默认没有设置文件路径，需要用户自己去设置，为了和另一款软件<code>Alfred</code>进行无缝协作，建议将文件路径设置在用户Document文件夹下。</p>
<h4 id="2-ToDo的BUG处理"><a href="#2-ToDo的BUG处理" class="headerlink" title="2. ToDo的BUG处理"></a>2. <code>ToDo</code>的BUG处理</h4><p><img src="http://img.geekerhua.com/blog/alfred5/14895760187086.jpg" alt=""><br>默认下载下来的代码有些bug，会导致对于完成的TODO，会显示两遍，一遍是未完成的白色状态，一遍是完成的灰色状态。需要对代码进行修复。<br><img src="http://img.geekerhua.com/blog/alfred5/14895761894277.jpg" alt=""></p>
<h4 id="3-Minimal-TODO插件的列表路径，有默认路径"><a href="#3-Minimal-TODO插件的列表路径，有默认路径" class="headerlink" title="3. Minimal-TODO插件的列表路径，有默认路径"></a>3. <code>Minimal-TODO</code>插件的列表路径，有默认路径</h4><p><code>Minimal-TODO</code>插件的默认路径推荐设置为<code>~/Documents/Alfred/todos/todo.txt</code>。你也可以根据需要进行设置，设置方法如下。</p>
<hr>
<h2 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h2><p><code>ToDo</code>的主题自定义，有序无序列表的设置。默认是<code>ul</code>无序列表，改为<code>ol</code>即为有序列表<br><img src="http://img.geekerhua.com/blog/alfred5/14896556515833.jpg" alt=""><br>将如图的ol改为ul，即为无序列表。</p>
<h2 id="关于Minimal-TODOworkflow的开发过程"><a href="#关于Minimal-TODOworkflow的开发过程" class="headerlink" title="关于Minimal-TODOworkflow的开发过程"></a>关于<code>Minimal-TODO</code>workflow的开发过程</h2><p>开发过程踩了很多坑，细节日后再补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;效果展示&quot;&gt;&lt;a href=&quot;#效果展示&quot; class=&quot;headerlink&quot; title=&quot;效果展示&quot;&gt;&lt;/a&gt;效果展示&lt;/h1&gt;&lt;p&gt;先来秀一张布置好的桌面图，怎么样是不是很清爽简约啊！&lt;br&gt;&lt;img src=&quot;http://img.geekerhua.c
    
    </summary>
    
      <category term="工具" scheme="blog.geekerhua.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="效率" scheme="blog.geekerhua.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="Alfred" scheme="blog.geekerhua.com/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>从碎片化阅读到知识的输出</title>
    <link href="blog.geekerhua.com/2017/03/12/read_to_write/"/>
    <id>blog.geekerhua.com/2017/03/12/read_to_write/</id>
    <published>2017-03-12T09:03:18.000Z</published>
    <updated>2017-03-12T09:24:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从碎片化阅读到知识的输出"><a href="#从碎片化阅读到知识的输出" class="headerlink" title="从碎片化阅读到知识的输出"></a>从碎片化阅读到知识的输出</h1><blockquote>
<p>先来一个最终的结论：(<code>即刻</code> + <code>Reeder</code>) -&gt; <a href="shouqu.me">收趣云书签</a> -&gt; (<code>印象笔记</code> + <code>markdown</code>)</p>
</blockquote>
<p>碎片化阅读，相对于读书，前者是泛读，后者是精读，在这里我们只讨论泛读的问题。</p>
<h2 id="为什么会出现碎片化阅读"><a href="#为什么会出现碎片化阅读" class="headerlink" title="为什么会出现碎片化阅读"></a>为什么会出现碎片化阅读</h2><p>在网络发达之前，人们的知识大多是通多读书来完成的，一本书很厚，每本书都对应着一个主题，通多阅读一整本书学的一定的知识。<br>而到了互联网时代，人人都可以进行内容输出，微博、头条、公众号的兴起更是加剧了碎片化，人们充斥在碎片化知识的海洋里，深度阅读越来越少，人的耐心也越来越差。收到海量的碎片化信息，如何合理的进行碎片化阅读以及将碎片化知识转化成自己的知识显得尤为重要。在经过多次尝试以及阅读量大量的文章之后，笔者总结出来一套相对完善的碎片化知识变现流程。</p>
<h3 id="阅读—-gt-整理—-gt-写作"><a href="#阅读—-gt-整理—-gt-写作" class="headerlink" title="阅读—&gt;整理—&gt;写作"></a>阅读—&gt;整理—&gt;写作</h3><p>阅读是为了获取信息，获取新的内容。而写作是对阅读到的信息进行整理，添加自己的思想，进行润色的产物。从知识的角度来说，阅读的内容是显性知识，显性知识要求通俗易懂，能够传递；当我们读了之后转化为隐性知识，隐性知识通常不太好进行传递，很多时候我们懂的知识无法传递给他人，好比”只可意会不可言传”一样；而写作就是将我们的隐性知识转化为显性知识，完成这样一个循环，这些知识才能彻彻底底的变成我们自己的。<code>输入—&gt;整理—&gt;输出</code>，一个循环，你可以在任何一个环节终止，来达到不同的目的。</p>
<h2 id="碎片化阅读"><a href="#碎片化阅读" class="headerlink" title="碎片化阅读"></a>碎片化阅读</h2><blockquote>
<p>泛读+稍后读</p>
</blockquote>
<p>大部分情况下，泛读知识读一下标题，不需要读完整个文章，甚至连文章都不要看，你只需要看标题，知道有这么一回事就够了。</p>
<p>而遇到优秀的文章，需要细细品味的内容，就需要采取稍后读，将这些文章放到稍后读应用中，在一个时间充裕，安静的环境下细细品读。</p>
<blockquote>
<p>Tips:<br>不要在泛读的过程中穿插深度阅读，这会大大降低阅读的效率。想想看，当你一屏一屏的浏览文章标题时，突然打开一片文章仔细看，然后看完了在返回，再一屏一屏浏览，想想这篇文章你看的效果也不会好到哪里去的。</p>
</blockquote>
<h3 id="泛读的入口"><a href="#泛读的入口" class="headerlink" title="泛读的入口"></a>泛读的入口</h3><ul>
<li>微信公众号</li>
<li>朋友圈</li>
<li>群、好友转发</li>
<li>微博</li>
<li>博客</li>
<li>头条</li>
<li>论坛</li>
<li>知乎</li>
<li>垂直门户<br>泛读的入口远远不止这么多，各行各业还有很多各自的垂直平台。如果放任这些入口不加控制，最终只会导致精力憔悴，看了很多没营养的，遗漏了很多有价值的，甚至不知不居中在“标题党”上浪费了很多宝贵的时间。</li>
</ul>
<p>因此我们要从源头控制这些信息，世面上有很多泛读类的聚合工具可以帮我们从一定程度上解决这些问题。</p>
<h3 id="泛读工具"><a href="#泛读工具" class="headerlink" title="泛读工具"></a>泛读工具</h3><ol>
<li>轻芒阅读</li>
<li>即刻</li>
<li>RSS<br>绝大多数情况下，泛读的入口可以归纳为<code>即刻</code>和<code>RSS</code>中，其中，<code>即刻</code>属于被动阅读，<code>RSS</code>属于主动阅读，而<code>轻芒阅读</code>的功能很大程度上与<code>即刻</code>重叠，因此不做推荐。</li>
</ol>
<p><code>轻芒阅读</code>原名<code>一览</code>，是豌豆荚旗下产品，核心功能是，将众多自媒体的文章进行聚合，用户选择订阅自己喜欢的自媒体或门户网站，这些媒体有文章更新就可以在app上进行阅读，相当于用着一款app干了很多app的事。<br><code>即刻</code>的核心是定制化内容，即刻有很多主题提醒，例如： “豆瓣8.5分以上的电影”、“一觉醒来世界发生了什么”、“折扣优惠精选”。<code>即刻</code>新推出了几个机器人，可以自定义规则抓取网上的信息，比如你关注python开发，你可以将几个网站的关于python的内容整合成一个提醒，这样，这些网站的的python内容如有更新，都会提醒你。<br><code>RSS</code>是一个老牌服务，但在这个流程中却相当重要，RSS如何使用这里就不做介绍了，这里只介绍如何更好地使用它。RSS更多的是订阅那种需要较细阅读的内容，而不是想各种自媒体一样雷同信息的内容。</p>
<ol>
<li>我们用RSS来订阅个人博客，这部分内容是以上两个工具抓取不到的；</li>
<li>还用来订阅微信公众号，很多公众号的文章质量都很优秀，但微信公众号中有很多事工具性质的，在这种环境下并不适合文章的阅读；</li>
<li>除此之外，还可以订阅一些优质的网站资源，例如国外网站。相信前两个做好了就已经收益无穷了，因为订阅源全都是自己精挑细选的，匹配性更高。<blockquote>
<p>对于RSS服务，推荐使用<a href="http://www.inoreader.com" target="_blank" rel="external">inoreader</a>，这是目前为止最好用的RSS服务，拥有Android和iOS客户端，且在iOS和mac平台上可以再Reeder应用中直接使用，那体验谁用谁知道。</p>
</blockquote>
</li>
</ol>
<h4 id="泛读流程"><a href="#泛读流程" class="headerlink" title="泛读流程"></a>泛读流程</h4><p>拥有了这三款应用或者后两款，并进行了针对自己合适的订阅。我们就可以开大餐了。</p>
<ol>
<li><p>在即刻中，进行标题泛读，不是很感兴趣的内容就直接跳过，只看标题。如果是标题党，直接放弃，不用点进去看了。对标题感兴趣的文章，点进去，快速浏览，尽量在5到10秒内判断出是否有价值进行细读，如果有，就使用分享丢到<code>收趣云书签</code>中，并分好类。如果没有要么直接返回，要么浏览一遍看完。</p>
<blockquote>
<p>如何判断是否需要细读，细读的文章，很多内容对你可能是有价值的，甚至能够在今后的某些地方进行引用，因此丢到<code>收趣云书签</code>中，稍后会进行标记，甚至整理到印象笔记中。</p>
</blockquote>
</li>
<li><p>在RSS的文章，已经是经过刷选过的内容了，绝大多数品质都很高，几乎没有标题党存在。这些文章数量相对要少很多，同样，觉得需要进行整理、标记、引用、日后会有价值的就分享到<code>收趣云书签</code>中，剩下的就可以慢慢看完了。</p>
</li>
</ol>
<h2 id="收集整理流程"><a href="#收集整理流程" class="headerlink" title="收集整理流程"></a>收集整理流程</h2><p>微博、知乎、豆瓣、简书等，会有很多优秀的内容，这些内容有的非常短，我们只是想把有价值的内容整理下，虽然这些平台都有自己的收藏系统，但如此分散，日后想再去找，估计早就忘了在哪个平台看到的了。因此手收集显得十分重要。</p>
<h3 id="常用的收集工具"><a href="#常用的收集工具" class="headerlink" title="常用的收集工具"></a>常用的收集工具</h3><ol>
<li>pocket</li>
<li>instapaper</li>
<li>方片收集</li>
<li>Raindrop.io</li>
<li>收趣云书签</li>
</ol>
<p>前两者都是响当当的稍后读应用，都可以用来做收集，后三个是相对比较小众的应用。这五款应用都是全平台可用的，目前都是免费的。但各有特色。<br>在使用这五款软件之后，最终我选择了收趣云书签，彻底放弃了其他4款应用。相对于其他几款应用，收趣云有如下独特的优势。</p>
<ol>
<li>能够导入几乎所有平台的文章，支持微信导入、微博导入；</li>
<li>对众多网站的文章进行内容重排；</li>
<li>能够很流畅的语音朗读文章，偶尔英文会按照单词去读；</li>
<li>出色的全文搜索功能，跨文章搜索；</li>
<li>笔记与标注功能，标注重点内容；<br>话说，语音朗读文章这个功能，很多时候解放了眼睛，就像挺书一样，值得使用。我们可以对文章添加标签，对重要的内容添加高亮，甚至添加标注，日后可以浏览这些标注，快速跳到标注的位置。</li>
</ol>
<h2 id="写作输出"><a href="#写作输出" class="headerlink" title="写作输出"></a>写作输出</h2><p>通过收趣云的收集、标签与标注功能，我们已经收集了大量的信息，对于同类的信息，我们可以进行整理，在收趣云的web页面中，将这些内容复制整理到印象笔记中，或者以markdown的形式写成博客进行输出，由此一个知识从输入到整理再到输出的环节就完成了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从碎片化阅读到知识的输出&quot;&gt;&lt;a href=&quot;#从碎片化阅读到知识的输出&quot; class=&quot;headerlink&quot; title=&quot;从碎片化阅读到知识的输出&quot;&gt;&lt;/a&gt;从碎片化阅读到知识的输出&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;先来一个最终的结论：(&lt;code&gt;
    
    </summary>
    
      <category term="成长" scheme="blog.geekerhua.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="方法论" scheme="blog.geekerhua.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>pyenv管理多版本python</title>
    <link href="blog.geekerhua.com/2017/02/06/Python_environment/"/>
    <id>blog.geekerhua.com/2017/02/06/Python_environment/</id>
    <published>2017-02-06T05:46:28.000Z</published>
    <updated>2017-02-13T05:34:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中不同项目对Python的版本有着不同的要求，Python2与Python3的差异，是的很多时候我们要同时使用者两种环境来做对比。众所周知，ipython的交互性设计能带来很大的方便。最理想的状态下就是能够随时切换Python的版本，且Python2与Python3能够并存，并且都能拥有自己的ipython和自己的pip包管理工具。</p>
<p>对于mac电脑来说，会自带Python2，该Python在<code>/usr/bin/python</code>，这个Python可以使用，安装插件，但无法删除。mac的很多功能都依赖与Python，因此，不建议对这个Python进行修改，安装包等操作。如果一不小心，出现问题，系统就会崩溃。</p>
<p>对于已经从Python官网上下载并安装的情况，最好把这个Python进行删除。</p>
<h3 id="删除Python官网下载的Python"><a href="#删除Python官网下载的Python" class="headerlink" title="删除Python官网下载的Python"></a>删除Python官网下载的Python</h3><pre><code>1    删除Python框架
2    sudo rm -rf /Library/Frameworks/Python.framework/Versions/x.x
3    删除Python程序
4    sudo rm -rf “/Applications/Python x.x”
5    删除/usr/local/bin目录下的Python连接
</code></pre><blockquote>
<p>x.x为Python的版本号</p>
</blockquote>
<h3 id="mac自带Python安装pip"><a href="#mac自带Python安装pip" class="headerlink" title="mac自带Python安装pip"></a>mac自带Python安装pip</h3><p>mac自带的Python是没有安装pip的，已不建议安装。如果需要安装，<br>mac里面Python自带easy_install的，最快的应该就是在terminal里面执行<code>sudo easy_install pip</code>，网络好几秒就ok。运行完可以用pip help测试一下是否安装成功，成功安装后，直接pip install numpy或者其他包就可以了。</p>
<h2 id="pyenv（最正规的好用的多版本管理工具）"><a href="#pyenv（最正规的好用的多版本管理工具）" class="headerlink" title="pyenv（最正规的好用的多版本管理工具）"></a><a href="https://github.com/yyuu/pyenv/" target="_blank" rel="external">pyenv</a>（最正规的好用的多版本管理工具）</h2><blockquote>
<p><a href="http://www.jianshu.com/p/a23448208d9a" target="_blank" rel="external">参考</a><br>这个pyenv会管理不同版本的Python，可以随时切换全局的Python版本，可以Python2与Python3并存，并且能够指定项目的Python版本。</p>
</blockquote>
<ol>
<li><p>安装pyenv</p>
 <figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ brew install pyenv</div></pre></td></tr></table></figure>
</li>
<li><p>添加到环境变量</p>
 <figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">'eval "$(pyenv init -)"'</span> &gt;&gt; ~/.zshrc</div></pre></td></tr></table></figure>
<blockquote>
<p>如果用的是bash，则将<code>.zshrc</code>修改为<code>.bashrc</code></p>
</blockquote>
</li>
<li><p>应用zsh(bash)设置</p>
 <figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">source</span> ~/.zshrc</div><div class="line">$ <span class="built_in">exec</span> <span class="variable">$SHELL</span> <span class="_">-l</span>     <span class="comment"># 输入命令重启 Shell,然后就可以重启pyenv</span></div></pre></td></tr></table></figure>
</li>
<li><p>安装python</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ pyenv install 3.6.0	<span class="comment"># 安装3.6.0版本</span></div></pre></td></tr></table></figure>
</li>
<li><p>重建索引</p>
 <figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ pyenv <span class="built_in">rehash</span></div></pre></td></tr></table></figure>
</li>
<li><p>设置全局pyhon版本</p>
 <figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ pyenv global 2.7.13 3.6.0</div></pre></td></tr></table></figure>
</li>
<li><p>指定项目python版本</p>
 <figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ pyenv <span class="built_in">local</span> 3.5.2</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>装好后，如需使用python3的pip，则使用pip3，使用python2的pip，则使用pip或pip2.ipython同理。</p>
<p>pyenv管理的python位于<code>~/.pyenv/versions/</code>中，并且全都在<code>~/.pyenv/shims/</code>中以软连接的形式存在，因此，无论版本怎么切换，<code>which python</code>的结果都应该是<code>~/.pyenv/shims/ipython</code></p>
</blockquote>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ pyenv version			<span class="comment"># 查看当前生效python版本</span></div><div class="line">$ pyenv versions		<span class="comment"># 查看已安装版本</span></div><div class="line">$ pyenv install --list	<span class="comment"># 查看可用版本</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="安装常见问题"><a href="#安装常见问题" class="headerlink" title="安装常见问题"></a>安装常见问题</h4><ol>
<li>安装时出现<code>zipimport.ZipImportError: can&#39;t decompress data; zlib not available</code>错误<a href="https://github.com/yyuu/pyenv/wiki/Common-build-problems" target="_blank" rel="external">官方的解释</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">解决方法1：</div><div class="line">$ brew install readline xz</div><div class="line">$ CFLAGS=&quot;-I$(xcrun --show-sdk-path)/usr/include&quot; </div><div class="line"></div><div class="line">解决方法2：</div><div class="line">1、安装依赖zlib、zlib-devel</div><div class="line">2、重新编译安装Python</div><div class="line"></div><div class="line">	1	./configure </div><div class="line">	2	编辑Modules/Setup文件 </div><div class="line">	3	找到下面这句，去掉注释 </div><div class="line">	4	#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz </div><div class="line">	5	重新编译安装：make &amp; make install</div></pre></td></tr></table></figure>
<h2 id="sublime支持python3直接运行并显示中文"><a href="#sublime支持python3直接运行并显示中文" class="headerlink" title="sublime支持python3直接运行并显示中文"></a>sublime支持python3直接运行并显示中文</h2><p>新建编译环境,输入以下内容<br><figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"cmd"</span>: [<span class="string">"$ which python3 的路径"</span>, <span class="string">"-u"</span>, <span class="string">"$file"</span>],  </div><div class="line">    <span class="attr">"env"</span>: &#123; <span class="attr">"PYTHONIOENCODING"</span>: <span class="string">"utf8"</span> &#125;   # 使Python3支持中文</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>选择新建的编译环境进行编译。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中不同项目对Python的版本有着不同的要求，Python2与Python3的差异，是的很多时候我们要同时使用者两种环境来做对比。众所周知，ipython的交互性设计能带来很大的方便。最理想的状态下就是能够随时切换Python的版本，且Python2与Python3能
    
    </summary>
    
      <category term="Python" scheme="blog.geekerhua.com/categories/Python/"/>
    
    
      <category term="环境配置" scheme="blog.geekerhua.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Python" scheme="blog.geekerhua.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令基础</title>
    <link href="blog.geekerhua.com/2017/01/13/Linux_foundation/"/>
    <id>blog.geekerhua.com/2017/01/13/Linux_foundation/</id>
    <published>2017-01-13T11:58:22.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="一些常用快捷键"><a href="#一些常用快捷键" class="headerlink" title="一些常用快捷键"></a>一些常用快捷键</h2><table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+c</td>
<td>结束当前任务</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>键盘输入结束或退出终端</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>暂停当前程序，暂停后按下任意键恢复运行</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>将当前程序放到后台运行，恢复到前台为命令fg，jobs查看当前后台任务</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td>将光标移至输入行头，相当于Home键</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>将光标移至输入行末，相当于End键</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>删除从光标所在位置到行末</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>删除当前行内容</td>
</tr>
<tr>
<td>Alt+Backspace</td>
<td>向前删除一个单词</td>
</tr>
<tr>
<td>Shift+PgUp</td>
<td>将终端显示向上滚动</td>
</tr>
<tr>
<td>Shift+PgDn</td>
<td>将终端显示向下滚动</td>
</tr>
</tbody>
</table>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><blockquote>
<p>$ touch love_{1..10}_linux.txt<br>一次创建多个文件</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配 0 或多个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配 list 中的任意单一字符</td>
</tr>
<tr>
<td>[!list]</td>
<td>匹配 除list 中的任意单一字符以外的字符</td>
</tr>
<tr>
<td>[c1-c2]</td>
<td>匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td>
</tr>
<tr>
<td>{string1,string2,…}</td>
<td>匹配 sring1 或 string2 (或更多)其一字符串</td>
</tr>
<tr>
<td>{c1..c2}</td>
<td>匹配 c1-c2 中全部字符 如{1..10}</td>
</tr>
</tbody>
</table>
<h2 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h2><blockquote>
<p>在 Linux 环境中，如果你遇到困难，可以使用man 命令，它是Manual page的缩写。<br>通常情况下，man 手册里面的内容都是英文的，这就要求你有一定的英文基础。man 手册的内容很多，涉及了 Linux 使用过程中的方方面面，为了便于查找，是做了分册（分区段）处理的，在Research UNIX、BSD、OS X 和 Linux 中，手册通常被分为8个区段</p>
</blockquote>
<table>
<thead>
<tr>
<th>区段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>一般命令</td>
</tr>
<tr>
<td>2</td>
<td>系统调用</td>
</tr>
<tr>
<td>3</td>
<td>库函数，涵盖了C标准函数库</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件（通常是/dev中的设备）和驱动程序</td>
</tr>
<tr>
<td>5</td>
<td>文件格式和约定</td>
</tr>
<tr>
<td>6</td>
<td>游戏和屏保</td>
</tr>
<tr>
<td>7</td>
<td>杂项</td>
</tr>
<tr>
<td>8</td>
<td>系统管理命令和守护进程</td>
</tr>
</tbody>
</table>
<p>要查看相应区段的内容，就在 man 后面加上相应区段的数字即可，如：<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ man 1 ls</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><h3 id="使用cat-tac和nl命令查看文件"><a href="#使用cat-tac和nl命令查看文件" class="headerlink" title="使用cat,tac和nl命令查看文件"></a>使用cat,tac和nl命令查看文件</h3><p>使用cat,tac和nl命令查看文件。使用cat,tac和nl命令查看文件。<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ cat -n passwd</div></pre></td></tr></table></figure></p>
<p><code>nl</code>命令，添加行号并打印，这是个比cat -n更专业的行号打印命令。<br>这里简单列举它的常用的几个参数：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">-b : 指定添加行号的方式，主要有两种：</div><div class="line">    -b a:表示无论是否为空行，同样列出行号(<span class="string">"cat -n"</span>就是这种方式)</div><div class="line">    -b t:只列出非空行的编号并列出（默认为这种方式）</div><div class="line">-n : 设置行号的样式，主要有三种：</div><div class="line">    -n ln:在行号字段最左端显示</div><div class="line">    -n rn:在行号字段最右边显示，且不加 0</div><div class="line">    -n rz:在行号字段最右边显示，且加 0</div><div class="line">-w : 行号字段占用的位数(默认为 6 位)</div></pre></td></tr></table></figure>
<h3 id="使用more和less命令分页查看文件"><a href="#使用more和less命令分页查看文件" class="headerlink" title="使用more和less命令分页查看文件"></a>使用more和less命令分页查看文件</h3><p>more 是简单地分页查看工具<br>less 是more和vi的结合体，功能强大</p>
<h3 id="使用head和tail命令查看文件"><a href="#使用head和tail命令查看文件" class="headerlink" title="使用head和tail命令查看文件"></a>使用head和tail命令查看文件</h3><p>更直接的只看一行， 加上-n参数，后面紧跟行数：<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ tail -n 1 /etc/passwd</div></pre></td></tr></table></figure></p>
<blockquote>
<p>关于tail命令，不得不提的还有它一个很牛的参数-f，这个参数可以实现不停地读取某个文件的内容并显示。这可让我们动态查看日志起到实时监视的作用。</p>
</blockquote>
<hr>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><blockquote>
<p>PATH环境变量是Linux下程序执行的搜索路径，通常全局环境变量使用大写。环境变量仅在当前线程内有效。</p>
</blockquote>
<h2 id="查看PATH"><a href="#查看PATH" class="headerlink" title="查看PATH"></a>查看PATH</h2><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> PATH</div></pre></td></tr></table></figure>
<h2 id="添加值"><a href="#添加值" class="headerlink" title="添加值"></a>添加值</h2><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ PATH=<span class="variable">$PATH</span>:/home/shiyanlou/mybin</div></pre></td></tr></table></figure>
<h2 id="添加到zsh自启动执行"><a href="#添加到zsh自启动执行" class="headerlink" title="添加到zsh自启动执行"></a>添加到zsh自启动执行</h2><blockquote>
<p>zsh的配置文件为.zshrc，bash的配置文件为.bashrc</p>
</blockquote>
<figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"PATH=<span class="variable">$PATH</span>:/home/shiyanlou/mybin"</span> &gt;&gt; .zshrc</div></pre></td></tr></table></figure>
<h2 id="变量修改"><a href="#变量修改" class="headerlink" title="变量修改"></a>变量修改</h2><table>
<thead>
<tr>
<th>变量设置方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${变量名#匹配字串}</td>
<td>从头向后开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td>${变量名##匹配字串}</td>
<td>从头向后开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td>${变量名%匹配字串}</td>
<td>从尾向前开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td>${变量名%%匹配字串}</td>
<td>从尾向前开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td>${变量名/旧的字串/新的字串}</td>
<td>将符合旧字串的第一个字串替换为新的字串</td>
</tr>
<tr>
<td>${变量名//旧的字串/新的字串}</td>
<td>将符合旧字串的全部字串替换为新的字串</td>
</tr>
</tbody>
</table>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">unset</span> path</div></pre></td></tr></table></figure>
<h2 id="环境变量修改立刻生效"><a href="#环境变量修改立刻生效" class="headerlink" title="环境变量修改立刻生效"></a>环境变量修改立刻生效</h2><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">source</span> .zshrc</div><div class="line">-----</div><div class="line">$ . ./.zshrc		<span class="comment"># 第一个点后边必须跟绝对路径</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h1><h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>whereis只能搜索二进制文件(-b)，man帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用locate命令。</p>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ locate /etc/sh</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意,它不只是在 etc 目录下查找并会自动递归子目录进行查找</p>
</blockquote>
<p>查找 /usr/share/ 下所有 jpg 文件：<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ locate /usr/share/\*.jpg</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意要添加*号前面的反斜杠转义，否则会无法找到</p>
</blockquote>
<p>如果想只统计数目可以加上-c参数，-i参数可以忽略大小写进行查找，whereis 的-b,-m，-s同样可以是使用。</p>
<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>which本身是 Shell 内建的一个命令，我们通常使用which来确定是否安装了某个指定的软件，因为它只从PATH环境变量指定的路径中去搜索命令：<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">which</span> ls</div></pre></td></tr></table></figure></p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。find命令强大到，要把它将明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。</p>
<p>在指定目录下搜索指定文件名的文件：<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ find /etc/ -name interfaces</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path] [option] [action]</p>
</blockquote>
<p>与时间相关的命令参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-atime</code></td>
<td>最后访问时间</td>
</tr>
<tr>
<td><code>-ctime</code></td>
<td>创建时间</td>
</tr>
<tr>
<td><code>-mtime</code></td>
<td>最后修改时间</td>
</tr>
</tbody>
</table>
<p>下面以-mtime参数举例：<br>    •    <code>-mtime n</code>: n 为数字，表示为在n天之前的”一天之内“修改过的文件<br>    •    <code>-mtime +n</code>: 列出在n天之前（不包含n天本身）被修改过的文件<br>    •    <code>-mtime -n</code>: 列出在n天之内（包含n天本身）被修改过的文件<br>    •    <code>newer file</code>: file为一个已存在的文件，列出比file还要新的文件名</p>
<hr>
<h1 id="文件系统操作及磁盘管理"><a href="#文件系统操作及磁盘管理" class="headerlink" title="文件系统操作及磁盘管理"></a>文件系统操作及磁盘管理</h1><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>查看磁盘情况<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">$ df -h		<span class="comment">#以大小形式显示，而不是block块形式</span></div></pre></td></tr></table></figure></p>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>查看文件夹大小<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 只查看1级目录的信息</span></div><div class="line">$ du -h <span class="_">-d</span> 0 ~</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><h2 id="使用type可以判断命令类型，是内部命令，还是其他的"><a href="#使用type可以判断命令类型，是内部命令，还是其他的" class="headerlink" title="使用type可以判断命令类型，是内部命令，还是其他的"></a>使用type可以判断命令类型，是内部命令，还是其他的</h2><ul>
<li>type ls</li>
<li>type vim</li>
<li>type ls</li>
</ul>
<h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><blockquote>
<p>zsh没有help命令，help命令用来显示shell内建命令的简要帮助信息。</p>
</blockquote>
<p>外部命令也可以使用help命令<br><figure class="highlight zsh"><table><tr><td class="code"><pre><div class="line">ls --help</div></pre></td></tr></table></figure></p>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>man 手册中一共有这么几个章节</p>
<table>
<thead>
<tr>
<th>章节数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Standard commands （标准命令）</td>
</tr>
<tr>
<td>2</td>
<td>System calls （系统调用）</td>
</tr>
<tr>
<td>3</td>
<td>Library functions （库函数）</td>
</tr>
<tr>
<td>4</td>
<td>Special devices （设备说明）</td>
</tr>
<tr>
<td>5</td>
<td>File formats （文件格式）</td>
</tr>
<tr>
<td>6</td>
<td>Games and toys （游戏和娱乐）</td>
</tr>
<tr>
<td>7</td>
<td>Miscellaneous （杂项）</td>
</tr>
<tr>
<td>8</td>
<td>Administrative Commands （管理员命令）</td>
</tr>
<tr>
<td>9</td>
<td>其他（Linux特定的）， 用来存放内核例行程序的文档。</td>
</tr>
</tbody>
</table>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><blockquote>
<p>如果man命令显示的信息还不够，可以用info命令。但zsh没有这个命令</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础命令&quot;&gt;&lt;a href=&quot;#基础命令&quot; class=&quot;headerlink&quot; title=&quot;基础命令&quot;&gt;&lt;/a&gt;基础命令&lt;/h1&gt;&lt;h2 id=&quot;一些常用快捷键&quot;&gt;&lt;a href=&quot;#一些常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;一些常
    
    </summary>
    
      <category term="Linux" scheme="blog.geekerhua.com/categories/Linux/"/>
    
    
      <category term="Shell" scheme="blog.geekerhua.com/tags/Shell/"/>
    
      <category term="Linux" scheme="blog.geekerhua.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>mac开发环境配置</title>
    <link href="blog.geekerhua.com/2017/01/12/mac_develop_environment/"/>
    <id>blog.geekerhua.com/2017/01/12/mac_develop_environment/</id>
    <published>2017-01-12T12:18:28.000Z</published>
    <updated>2017-02-16T03:07:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a></h1><blockquote>
<p>Shell神器,OS X 不可或缺的套件管理器。<code>Homebrew</code>较之于<code>Shell</code>,好比<code>CocoaPod</code>较之于<code>Xcode</code>。这么说,<code>Homebrew</code>的定位就应该相当明确了吧！</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 安装</span></div><div class="line">ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 卸载</span></div><div class="line"> ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)"</span></div></pre></td></tr></table></figure>
<ul>
<li>更新已安装的package<ul>
<li>先更新brew：$ <code>brew update</code></li>
<li>更新所有package：$ <code>brew upgarde</code></li>
</ul>
</li>
<li>Homebrew下载的package存放的路径在哪里？<ul>
<li><code>/Library/Caches/Homebrew/</code></li>
</ul>
</li>
</ul>
<p>Homebrew 可以很方便的安装需要的套件,方法如下：$ <code>brew install wget</code>。是不是很简单？</p>
<p>Homebrew 使 OS X 更完美。使用 gem 来安装 gems、用 brew 来搞定那些依赖包。</p>
<blockquote>
<p>Tips: 如果安装过程中提示错误,提示先卸载,但执行卸载命令又卸载不掉,说明有曾经安装失败过,有残留。解决方式删除<code>/usr/local</code>文件夹即可。</p>
</blockquote>
<p><img src="http://7xtibb.com2.z0.glb.qiniucdn.com/2016-06-06-Shell_Homebrew安装失败.png" alt="Shell_Homebrew安装失败"></p>
<h2 id="优秀的命令工具"><a href="#优秀的命令工具" class="headerlink" title="优秀的命令工具"></a>优秀的命令工具</h2><h3 id="1-htop"><a href="#1-htop" class="headerlink" title="1.htop"></a>1.htop</h3><blockquote>
<p>带颜色的top工具，能够显示内存和CPU使用情况</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">brew install htop</div></pre></td></tr></table></figure>
<h3 id="2-brew-cask"><a href="#2-brew-cask" class="headerlink" title="2.brew cask"></a>2.<a href="https://caskroom.github.io" target="_blank" rel="external">brew cask</a></h3><blockquote>
<p>一个基于终端的软件安装工具</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">brew tap caskroom/cask</div></pre></td></tr></table></figure>
<ul>
<li>安装软件(比如安装chrome)<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">brew cask install google-chrome</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-tree"><a href="#3-tree" class="headerlink" title="3.tree"></a>3.tree</h3><blockquote>
<p>tree可以显示目录树,类似于ubuntu中的tree。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">brew install tree</div></pre></td></tr></table></figure>
<blockquote>
<p>tree命令在mac下并不太好用，中文显示乱码有个解决方法如下，这是一个自己写的tree功能，支持中文显示</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">alias</span> tree=<span class="string">"find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"</span></div></pre></td></tr></table></figure>
<h3 id="4-wget"><a href="#4-wget" class="headerlink" title="4.wget"></a>4.<a href="http://baike.baidu.com/link?url=_4E-kuBinS_AItjdR3vsisJTYpRsOCav7kEUifcKfUsLGMAML6kPVKJK0tVd5tOhLP13C_BnTzI7yFHFENwiKq" target="_blank" rel="external">wget</a></h3><blockquote>
<p>wget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">brew install wget</div></pre></td></tr></table></figure>
<hr>
<h1 id="xcode-selected"><a href="#xcode-selected" class="headerlink" title="xcode-selected"></a>xcode-selected</h1><blockquote>
<p>Mac下很多工具都需要xcode-selected支持，比如git。<br>如果没有安装的话，在终端输入<code>git</code>，会提示安装xcode commond line 工具。安装即可。</p>
</blockquote>
<hr>
<h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><blockquote>
<p>Linux及Mac默认的shell是Bash，但功能最强大的shell确实zsh，mac自带zsh，只是没有设置为默认shell，且shell配置复杂。使用oh-my-zsh进行配置,简单又强大.配合iTerm 2一同使用,简单又强大。</p>
</blockquote>
<ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">git <span class="built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</div></pre></td></tr></table></figure>
</li>
<li><p>创建备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">cp ~/.zshrc ~/.zshrc.orig</div><div class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</div></pre></td></tr></table></figure>
</li>
<li><p>把 zsh 设置成默认的 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">chsh <span class="_">-s</span> /bin/zsh</div></pre></td></tr></table></figure>
</li>
<li><p>重启zsh</p>
</li>
</ul>
<hr>
<h1 id="ruby升级"><a href="#ruby升级" class="headerlink" title="ruby升级"></a>ruby升级</h1><blockquote>
<p>rvm是什么？为什么要安装rvm呢，因为rvm可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。</p>
</blockquote>
<p>第一步安装rvm<br><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">$ curl -L get.rvm.io <span class="params">| bash -s stable</span></div><div class="line">$ source ~/.rvm/scripts/rvm</div></pre></td></tr></table></figure></p>
<ul>
<li>等待终端加载完毕,后输入：<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rvm -v</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果能显示版本好则安装成功了。<br>第二步：安装ruby</p>
<ul>
<li><p>列出ruby可安装的版本信息</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rvm list known</div></pre></td></tr></table></figure>
</li>
<li><p>安装一个ruby版本</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rvm install <span class="number">2.1</span>.<span class="number">4</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果想设置为默认版本，可以用这条命令来完成<br><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rvm use <span class="number">2.1</span>.<span class="number">4</span> --default</div></pre></td></tr></table></figure></p>
<ul>
<li><p>查看已安装的ruby</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rvm list</div></pre></td></tr></table></figure>
</li>
<li><p>卸载一个已安装ruby版本</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rvm remove <span class="number">2.1</span>.<span class="number">4</span></div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h1><blockquote>
<p>CocoaPods是Xcode的包管理工具，主要用在OC中，Swift中也能应用。帮助开发者管理iOS第三方框架的工具</p>
</blockquote>
<ul>
<li><ol>
<li>查看当前的ruby源: <code>gem source -l</code></li>
</ol>
</li>
<li><ol>
<li>修改ruby源<ul>
<li>删除旧源: gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a></li>
<li>添加新源:  <a href="https://gems.ruby-china.org/" target="_blank" rel="external">https://gems.ruby-china.org/</a></li>
<li>查看新源: gem source -l</li>
</ul>
</li>
</ol>
</li>
<li>3.安装CocoaPods: sudo gem install cocoapods (可能需要等待较长时间)</li>
<li><p>4.利用CocoaPods管理第三方框架</p>
<ul>
<li>打开Xcode新建项目</li>
<li>利用终端进入新项目的根路径</li>
<li>新建Podfile文件: vim Podfile, 在这个文件中描述需要依赖的第三方框架<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">platform :ios, &apos;8.0&apos;</div><div class="line">pod &apos;UIView+AutoLayout&apos;, &apos;~&gt; 2.0&apos;</div><div class="line">pod &apos;MJExtension&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>5.解析Podfile文件</p>
<ul>
<li>建议先更新远程的框架信息: pod setup</li>
<li>开始解析Podfile文件: pod install (可能需要等待较长时间)<ul>
<li>pod install 换成pod install –verbose –no-repo-update这个命令，前面的命令被墙了 ,pod update 同理</li>
</ul>
</li>
<li>如果需要更新框架: pod update</li>
</ul>
</li>
<li>6.其它用法<ul>
<li>使用pod search 关键词可以搜索支持CocoaPods的第三方框架 (并不是所有第三方框架都支持CocoaPods)</li>
<li>建议在进行pod search、pod update、pod install之前都先进行pod setup</li>
<li>如果在使用CocoaPods过程中遇到了莫名其妙的错误（比如NoMethodError），大部分原因是mac上的Ruby环境不是最新的。可以考虑更新Ruby环境: sudo gem update</li>
</ul>
</li>
<li>直接在终端添加新依赖  $  pod ‘SVProgressHUD’, ‘~&gt; 1.1.2’ &gt; Podfile</li>
</ul>
<hr>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><blockquote>
<p>vim号称编辑器之神，拥有强大的功能和众多的插件。</p>
</blockquote>
<h2 id="中文帮助文件"><a href="#中文帮助文件" class="headerlink" title="中文帮助文件"></a><a href="http://sourceforge.net/projects/vimcdoc/files/latest/download" target="_blank" rel="external">中文帮助文件</a></h2><ul>
<li>安装<a href="http://sourceforge.net/projects/vimcdoc/files/latest/download" target="_blank" rel="external">http://sourceforge.net/projects/vimcdoc/files/latest/download</a></li>
<li><p>解压后进入文件夹,执行 <code>sudo ./vimcdoc.sh -i</code> #安装</p>
<blockquote>
<p>vim中文文档不会覆盖原英文文档，安装后vim默认使用中文文档。若想使用英文文档，可在vim中执行以下命令：</p>
</blockquote>
<ul>
<li><p>:set helplang=en  回车之后 :help 就是英文的help。</p>
<blockquote>
<p>同理，使用以下命令可重新使用中文文档：</p>
</blockquote>
</li>
<li><p>:set helplang=cn 回车之后 :help 就是中文的help。</p>
</li>
</ul>
</li>
<li>在解包之后的文件夹中使用以下命令可以卸载vim中文文档：<ul>
<li>$sudo ./vimcdoc.sh -u</li>
</ul>
</li>
</ul>
<hr>
<h1 id="sublime-text3"><a href="#sublime-text3" class="headerlink" title="sublime text3"></a>sublime text3</h1><h2 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a><a href="https://sublime.wbond.net/packages/Package%20Control" target="_blank" rel="external">Package Control</a></h2><blockquote>
<p>提到 Sublime Text，就不得不说 Package Control，就像 Linux 下的 apt-get 和 yum 一样，它是 Sublime Text 的包管理器，你用它可以轻松地找到你想要的插件和管理已有插件。</p>
</blockquote>
<ul>
<li>使用<code>control</code> + <code>~</code>打开控制台，将从官网<a href="https://sublime.wbond.net/installation#st3" target="_blank" rel="external">复制代码</a>粘贴到控制台并执行。</li>
<li>安装代码如下<pre><code>import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed\_packages\_path(); urllib.request.install\_opener( urllib.request.build\_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)
</code></pre><h3 id="Package-Control-常用命令"><a href="#Package-Control-常用命令" class="headerlink" title="Package Control 常用命令"></a>Package Control 常用命令</h3></li>
<li>激活<code>cmd+shift+P</code></li>
<li>安装插件 ->  Package Control: Install Package xxx</li>
<li>显示所有已安装的插件 -> List Packages </li>
<li>移除一个指定的插件 -> Remove Packages </li>
<li>更新一个指定的插件 -> Upgrade Package </li>
<li>更新所有已安装的插件 -> Upgrade/Overwrite All Packages </li>
</ul>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><ul>
<li><p><a href="http://docs.emmet.io" target="_blank" rel="external">emmet</a></p>
<blockquote>
<p><a href="http://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">速查表</a><br><a href="http://docs.emmet.io/" target="_blank" rel="external">官方文档</a></p>
</blockquote>
<ul>
<li>安装<ul>
<li>按Ctrl+Shift+P命令板</li>
<li>输入install然后选择install Package，然后输入emmet找到 Emmet Css Snippets，点击就可以自动完成安装。</li>
</ul>
</li>
</ul>
</li>
<li>Better Completion<ul>
<li>自动补全Bootstrap 、JQuery、Less等<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3></li>
</ul>
</li>
<li>SubLimener<ul>
<li>编码规范</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Homebrew&quot;&gt;&lt;a href=&quot;#Homebrew&quot; class=&quot;headerlink&quot; title=&quot;Homebrew&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://brew.sh/index_zh-cn.html&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="Other" scheme="blog.geekerhua.com/categories/Other/"/>
    
    
      <category term="Shell" scheme="blog.geekerhua.com/tags/Shell/"/>
    
      <category term="环境配置" scheme="blog.geekerhua.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>信息爆炸的时代，该怎么有效获取信息</title>
    <link href="blog.geekerhua.com/2017/01/08/infomation/"/>
    <id>blog.geekerhua.com/2017/01/08/infomation/</id>
    <published>2017-01-08T10:00:00.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>如今社会是一个信息爆炸的时代，我们有多种多样的渠道可以获取信息，但又有读不完的信息。如何最低成本获取到有价值的信息显得尤为重要，因此对信息渠道进行筛选和入口统一显得尤为重要。RSS已死，RSS永生。</p>
</blockquote>
<h2 id="过去的我的信息获取渠道及方式"><a href="#过去的我的信息获取渠道及方式" class="headerlink" title="过去的我的信息获取渠道及方式"></a>过去的我的信息获取渠道及方式</h2><ul>
<li>电视，据统计，目前一年产生的电视节目，可供我们从现在看到2040年。但电视节目充满了夸张的广告，且电视的信息属于被动输入，无法主动选择。我个人看电视，觉得最有价值的就是看广告，能够欣赏广告词设计及画面</li>
<li>报纸，传统的报纸已经存在很多年了，虽然现在报纸发行量明显减少，但不可否认为我们传达了大量的信息。现在的报纸由于受到网络信息的冲击，不再具有时效性，很多报纸充斥着大量的广告。</li>
<li>杂志，作为跨越报纸与多媒体的产物，信息量更大的杂志也曾风靡一时，融合图片、文字，甚至还带有多媒体光盘。不过众多杂志也都纷纷停刊。也有不少杂志依旧存在。</li>
<li>论坛，论坛拥有顽强的生命力，开创了粉丝间的互动，我们第一次获取到了和我们一样平常人的信息，而不是所有的信息都来自官方。</li>
<li>微信公众号, 微信的兴起，开创了知识获取的新渠道，普通人也能够成为知识分享者，知识获取的方式更加简单，便捷。很多人通过些公众号文章来锻炼自己地写作能力，记录自己。随时随地、碎片化阅读，为公众号的传播提供了便利。每天一条新的消息，用不了几分钟就读完了。貌似还不错。</li>
<li>RSS 一项古老的技术，能够订阅一些网站、博客的文章，定期或者及时进行更新，并能够对文章进行分类和标记。在Google Reader退出后，逐渐冷淡。</li>
<li>博客、微博：博客和微博属于相似的形式，只不过一个是基于PC端，一个是基于移动端。一个是基于长文本，一个是基于短文本。每个人都应该有属于自己的博客，用来树立自己的形象。自己搭建博客的成本真的是越来越低了。</li>
<li>垂直网站： 垂直网站专注于他所专注的领域，不想各大门户网站，充斥着各种类型的信息，用户所关心的往往是极个别的领域。因此垂直网站是一个很好的项目，我们关注我们所关心的领域，并随时查看相应的垂直网站，能够获取到新鲜及时的信息。</li>
<li>《今日头条》、《网易新闻》为代表的资讯类App，移动端的兴起，带火了这类应用，本身是一个聚合平台，但由于可以自定义不同的领域，你将可以只看到自己希望关注的领域，不受其他无用咨询的打扰。</li>
<li>book： 信息爆照时代，我们大多数的信息的获取来源是利用碎片化的时间，碎片化的时间意味着，没有深度阅读，阅读往往停留在表面。这会让人很浮躁，看到一大片文字，往往一掠而过，不会仔细去读，往往看完了，并不记得讲的是什么了。读一本，一本专注于一个主题的书，能够更加系统的对主题进行阐述和讲解，阅读这样的书籍更能够培养深度阅读能力。看书什么时候也是不能被替代的。</li>
<li>邮件订阅《卖桃者说》——MacTalk池建强： 随着时代的发展，又出现了一种邮件订阅的知识获取途径，第一次接触是某个技术网站的电子期刊订阅，这是免费的，但相应的，免费的也是最贵的。因此这类订阅往往不是太受重视，特别是天朝垃圾邮件这么多，每天都有好多封邮件，真的很头疼。<ul>
<li>但依然个别邮件订阅却做得很不错，例如《卖桃者说》这是一个付费的信息订阅。价格也很贵，每周一封，每次是关于一个主题，优点是，信息是多媒体的，而且信息随时随地都可以看，在哪里都可以看，因为是收费的，你也就不会忽视它，反而会每周期待他的到来，邮件的形式也很适合与作者沟通交流。缺点就是毕竟是基于邮件，信息的管理不是很方便。</li>
</ul>
</li>
<li>有声电台：随着播客的兴起，特别是《喜马拉雅》的流行，在国内，出现了众多以声音为媒介的知识分享，对每个用户来说，都可以成为信息的提供方，将自己的知识、经验进行分享。有免费的、也有收费的。本着免费的也是最贵的原则，你会发现收费的往往没那么多废话，内容也是充满干活，能够学到更多的东西。例如喜马拉雅在12月13日举行了知识付费节，很多收费课程都是半价优惠。很多节目，50块钱就能学很久。</li>
<li>视频：大部分免费的视频缺陷就是，啰嗦，比较浪费时间，看着很着急。</li>
</ul>
<blockquote>
<p>讲了这么多信息的获取渠道，是不是大开眼界，很多自己都没有尝试呢。其实对于我们来说，最值钱的就是时间，每个人的时间都是有限的，如何合理利用自己的时间，比别人多获取更多的有效信息呢。我整理了自己的信息获取途径。</p>
</blockquote>
<h2 id="现在我的信息获取渠道及方式"><a href="#现在我的信息获取渠道及方式" class="headerlink" title="现在我的信息获取渠道及方式"></a>现在我的信息获取渠道及方式</h2><ul>
<li>RSS<ul>
<li>这是我最推崇的信息获取方式，一般的图文信息，包括、博客、垂直网站，甚至是公众号都可以使用RSS进行订阅。</li>
<li>传统的电视早已成为了时间杀手，我们要远离，能有多远，跑多远。</li>
<li>杂志从某个角度来说早已退出了当今的社会。</li>
<li>报纸的核心就是时效性，如今有太多的渠道要强于报纸。</li>
<li>论坛里充满了各种水贴，真正有价值的信息很难找、也很少。</li>
<li>而微博，更多的是博主与粉丝的互动，没有太多的有价值信息。</li>
<li>真正有价值的图文信息通常在个别的高质量垂直网站、个人博客、微信公众号。使用RSS进行订阅，能够进行统一管理，分类，标识读过的信息，对优秀的信息进行归档等。</li>
</ul>
</li>
<li>极个别的网站(ithome)<ul>
<li>有些网站并不支持RSS订阅，有些网站具有大量的信息输出，且涉及不同的领域，这些网站就需要加入收藏夹，自己定期查看，以获取有价值的信息，比如：掘金、InfoQ、github、开源中国等。</li>
</ul>
</li>
<li>book(包括Kindle)<ul>
<li>看书是最能提高人认知的活动。纸质书无疑更有感觉，但纸质书多了对经济和存放空间都是一种挑战，因此Kindle为首的电子书才会如此流行。</li>
</ul>
</li>
</ul>
<h3 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h3><ul>
<li>优秀的公众号：<ul>
<li>小道消息</li>
<li><a href="http://www.infoq.com/cn/" target="_blank" rel="external">InfoQ</a></li>
<li><a href="http://macshuo.com" target="_blank" rel="external">malkTalk</a></li>
<li>学习学习在学习</li>
<li><a href="http://www.write.org.cn" target="_blank" rel="external">warfalcon</a></li>
<li><a href="xinshengdaxue.com">新生大学</a></li>
<li><a href="http://guokr.com" target="_blank" rel="external">果壳网</a></li>
</ul>
</li>
<li>优秀的网站 <ul>
<li><a href="http://sspai.com" target="_blank" rel="external">少数派</a></li>
<li><a href="http://www.iplaysoft.com" target="_blank" rel="external">异次元软件世界</a></li>
<li><a href="http://www.waerfa.com" target="_blank" rel="external">Mac玩儿法</a></li>
</ul>
</li>
<li>博客<ul>
<li><a href="http://www.liaoxuefeng.com" target="_blank" rel="external">廖雪峰</a></li>
<li><a href="http://www.ruanyifeng.com" target="_blank" rel="external">阮一峰</a></li>
<li>……</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如今社会是一个信息爆炸的时代，我们有多种多样的渠道可以获取信息，但又有读不完的信息。如何最低成本获取到有价值的信息显得尤为重要，因此对信息渠道进行筛选和入口统一显得尤为重要。RSS已死，RSS永生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id
    
    </summary>
    
      <category term="Speak" scheme="blog.geekerhua.com/categories/Speak/"/>
    
    
      <category term="成长" scheme="blog.geekerhua.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>戒了吧拖延症</title>
    <link href="blog.geekerhua.com/2016/11/15/procrastination/"/>
    <id>blog.geekerhua.com/2016/11/15/procrastination/</id>
    <published>2016-11-15T10:00:00.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>拖延症是每个人的噩梦，但很多人并没有这样的意识。拖延会让你失去很多机会，会降低效率(包括工作效率，生活上的效率，以及各种效率)。</p>
</blockquote>
<p>本书的主人公胡小懒，从一个做事拖延，散漫的人到逐渐认清自己，再观察别人的情况，反思自己的行为表现，最终一步步告诫自己、制定计划，走出拖延的泥潭。</p>
<p>本书共有10大章节，每个章节都围绕一个主题展开。</p>
<h2 id="拖延在靠近"><a href="#拖延在靠近" class="headerlink" title="拖延在靠近"></a>拖延在靠近</h2><p>拖延的类型，无外乎有一下几个。</p>
<ol>
<li>工作型拖延</li>
<li>学习型拖延</li>
<li>瞎忙型拖延</li>
<li>被动型拖延</li>
<li>侥幸型拖延</li>
<li>苛求型拖延</li>
</ol>
<h2 id="拖延的危害"><a href="#拖延的危害" class="headerlink" title="拖延的危害"></a>拖延的危害</h2><ul>
<li>拖延会无意义的浪费生命，而需要做的事没有完成，早晚还是要花费时间去做的。</li>
<li>拖延还会是的情况一团糟，既有的计划可能会被打乱，突发的情况更会让事情变得无法收拾，变得一团糟糕。</li>
<li>拖延会对心里产生压力，让人颓废。</li>
<li>当然工作中的拖延很可能会让你丢掉工作。</li>
</ul>
<p>拖延症的计算公式<br><code>U = EV/ID</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">U：完成给定任务的愿望</div><div class="line">E：对成功的期望</div><div class="line">V：创造的价值</div><div class="line">I：任务的紧迫性</div><div class="line">D：主观拖延的程度</div></pre></td></tr></table></figure>
<blockquote>
<p>这个公式意味着，人往往会拖延那些无法立刻见到回报的事，而是会把经理全部放在能够直接产生效益的活动上。</p>
</blockquote>
<h2 id="我们为什么会拖延"><a href="#我们为什么会拖延" class="headerlink" title="我们为什么会拖延"></a>我们为什么会拖延</h2><ul>
<li>因为心里问题，心里问题导致有些事情我们不愿意去做；</li>
<li>因为懒惰，懒惰会使我们变得拖延；</li>
<li>部分情况因为完美主义，我们会等待，继而变成了拖延；</li>
<li>因为害怕失败，我们也会进行逃避，不敢去面对，就不回去做，变得拖延；</li>
<li>害怕抉择，害怕做决定，让我们拖延；</li>
<li>甚至我们会害怕成功，比如升值了怕不能胜任而去拖延；</li>
<li>人不是独立个体，当我们太过依赖别人的时候也会产生拖延。</li>
</ul>
<h2 id="如何战胜拖延呢"><a href="#如何战胜拖延呢" class="headerlink" title="如何战胜拖延呢"></a>如何战胜拖延呢</h2><p>首先要克服懒惰，原理懒惰，就已经成功一半了。当不想行动时，用语言提醒自己，别犯懒。要克服拖延。</p>
<h3 id="PDCA循环法"><a href="#PDCA循环法" class="headerlink" title="PDCA循环法"></a>PDCA循环法</h3><p>Plan(计划) ->Do(执行) -> Check(检查) -> Action(行动)</p>
<ul>
<li>要克服懒惰，就必须先有计划；</li>
<li>提高执行力，在执行的过程中，时刻提醒自己，不能犯懒。</li>
<li>自检和被检。自检是一种自省，可以不断地发现自身存在的问题，从而解决问题。被检则是将自己置身于优秀的监督机制中。</li>
<li>检查是为了发现问题、解决问题。检查之后就要采取行动。</li>
</ul>
<h2 id="与借口说bye-bye"><a href="#与借口说bye-bye" class="headerlink" title="与借口说bye-bye"></a>与借口说bye-bye</h2><ul>
<li>生活的赢家，从来没有借口；</li>
<li>负责的人，从来没有借口。<h2 id="打造强大的执行力"><a href="#打造强大的执行力" class="headerlink" title="打造强大的执行力"></a>打造强大的执行力</h2></li>
<li>快速决定、一分钟也不耽误，重要的事不能拖得最后，要先做；</li>
<li>优先处理讨厌的工作。赶走负面情绪，收回注意力。<h2 id="有目标的人，才不拖延"><a href="#有目标的人，才不拖延" class="headerlink" title="有目标的人，才不拖延"></a>有目标的人，才不拖延</h2></li>
<li>有什么样的目标，就有什么样的人生；</li>
<li>不瞎忙，有一个明确的目标；</li>
<li>任何目标都要有个Deadline；</li>
<li>专注眼前，一次只做一点事；</li>
<li>把大目标分解成小目标<h2 id="时间管理，终结拖延恶习"><a href="#时间管理，终结拖延恶习" class="headerlink" title="时间管理，终结拖延恶习"></a>时间管理，终结拖延恶习</h2></li>
<li>二八法则</li>
<li>四象限法则<h2 id="来点正能量"><a href="#来点正能量" class="headerlink" title="来点正能量"></a>来点正能量</h2></li>
<li>输给别人，别输给自己</li>
<li>让工作氛围积极起来；</li>
<li>让工作变得有趣；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;拖延症是每个人的噩梦，但很多人并没有这样的意识。拖延会让你失去很多机会，会降低效率(包括工作效率，生活上的效率，以及各种效率)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本书的主人公胡小懒，从一个做事拖延，散漫的人到逐渐认清自己，再观察别人的情况
    
    </summary>
    
      <category term="Reading" scheme="blog.geekerhua.com/categories/Reading/"/>
    
    
      <category term="读书笔记" scheme="blog.geekerhua.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swift Protocal实战1(Refreshable)</title>
    <link href="blog.geekerhua.com/2016/06/18/Swift_protocal_refreshable/"/>
    <id>blog.geekerhua.com/2016/06/18/Swift_protocal_refreshable/</id>
    <published>2016-06-18T13:57:21.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在app的开发中，出现最多的一个情况就是显示一个列表来展示数据，就像刷微博一样，要能够上拉加载更多，下拉进行刷新。但在实际开发过程中，需要考虑的情况会更多。我们使用<code>header</code>来表示下拉刷新控件，使用<code>footer</code>来表示上拉加载控件。</p>
</blockquote>
<h2 id="在不考虑缓存的情况下单数据源tableView需要考虑以下注意点"><a href="#在不考虑缓存的情况下单数据源tableView需要考虑以下注意点" class="headerlink" title="在不考虑缓存的情况下单数据源tableView需要考虑以下注意点"></a>在不考虑缓存的情况下单数据源tableView需要考虑以下注意点</h2><ol>
<li>首次进入这个页面，没有数据需要进行首次数据加载</li>
<li>首次加载过程中不能显示footer</li>
<li>下拉刷新需要用返回的结果覆盖数据源的数据</li>
<li>下拉刷新后需要还原footer的状态(变更为可以加载更多)</li>
<li>上拉加载成功后需要根据返回数据数量来判断是否还有更多数据，没有更多数据需要修改footer的状态为<code>没有更多数据了</code>，并禁止上拉刷新功能。</li>
<li>首次加载数据如果没有网络连接或者加载失败，需要显示一个失败页面，点击失败页面能够重新进行网络请求获取数据。</li>
<li>每次进行下拉刷新都需要将当前page设为<code>1</code></li>
<li>每次进行上拉加载前都需要将当前page进行<code>+1</code>操作</li>
<li>每次上拉加载失败都需要将当前page进行<code>-1</code>操作，以还原防止，下次上拉加载page多加了的问题</li>
</ol>
<h2 id="如果是多数据源的tableView则需要考虑的更多"><a href="#如果是多数据源的tableView则需要考虑的更多" class="headerlink" title="如果是多数据源的tableView则需要考虑的更多"></a>如果是多数据源的tableView则需要考虑的更多</h2><ol>
<li>首先就是不同数据源的page记录，每个数据源都需要对应一个自己的page</li>
<li>每个数据源都需要记录是否还有更多数据可供加载</li>
<li>甚至每个数据源拥有各自的没数据的文字提示</li>
<li>实际项目中，为了一些效果，还需要记录当前数据源是否处于加载数据状态，以此来显示某些加载页面。</li>
<li>可能还会有一个个性化的定制需求</li>
</ol>
<blockquote>
<p>综上所述，仅仅是一个控制器的数据加载逻辑就有这么多，如果有很多这样类似的页面，每次都要考虑这么多问题，难免会有不少疏忽，而且要实现这些功能会产生大量的重复代码，这肯定是我们不希望看到的。</p>
</blockquote>
<p>分析上述需求我们发现，实际上通常我们所接触的<code>tableView</code>大体上也就需要注意这么多问题，而且为了整个工程的统一性，一般情况所有的处理也是采用同一套逻辑，因此我们完全可以把这些逻辑统一起来，使用一个<code>Protocol</code>来实现这些逻辑。得益于Swift强大的<code>Protocol Extention</code> 大部分情况我们只需要在合适的关键点调用几个方法就可以了，所有的逻辑默认都已经实现了。<code>Controller</code>中的代码更少了，不相关的逻辑都封装好了，逻辑更加简洁了。</p>
<h2 id="控制器使用代码"><a href="#控制器使用代码" class="headerlink" title="控制器使用代码"></a>控制器使用代码</h2><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PYMyOrderListController</span>: <span class="title">PYBaseViewController</span>, <span class="title">Refreshable</span> </span>&#123;</div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> refreshStatus: [(page: <span class="type">Int</span>, isLoading: <span class="type">Bool</span>, noMoreData: <span class="type">Bool</span>, noMoreTitle: <span class="type">String</span>)] = [(<span class="number">1</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="string">"没有更多订单了"</span>)]     <span class="comment">// 定义每个数据源需要的四个属性，分别是当前页码，是否被正在加载中，是否没有更多数据可供加载了。没有数据可供加载的footer文字</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> currentIndex = <span class="number">0</span>       <span class="comment">// 当前现实的数据源索引</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> refreshTable: <span class="type">UITableView</span> = <span class="type">UITableView</span>()      <span class="comment">// 当前tableView</span></div><div class="line">   </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">         view.addSubview(tableView)</div><div class="line">         tableView.snp_makeConstraints &#123; (make) <span class="keyword">in</span></div><div class="line">                     make.<span class="keyword">left</span>.<span class="keyword">right</span>.bottom.equalTo(<span class="number">0</span>)</div><div class="line">                     make.top.equalTo(segementView.snp_bottom)</div><div class="line">             &#125;</div><div class="line">         refreshTable = tableView       <span class="comment">// 赋值当前tableView</span></div><div class="line">         setupRefreshHeader()           <span class="comment">//初始化下拉刷新控件</span></div><div class="line">         setupRefreshFooter()           <span class="comment">// 初始化上拉加载控件</span></div><div class="line">     &#125;    </div><div class="line">        <span class="comment">///  加载数据的方法</span></div><div class="line">        <span class="comment">///</span></div><div class="line">        <span class="comment">///  - parameter isRefresh: 是否是下拉刷新</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">refreshData</span><span class="params">(isRefresh: Bool)</span></span> &#123;    </div><div class="line">        refreshStatus[currentIndex].isLoading = <span class="literal">true</span>        <span class="comment">// 修改当前数据源的加载状态为正在加载</span></div><div class="line">        <span class="keyword">let</span> indexItem = currentIndex</div><div class="line">        <span class="keyword">let</span> url = <span class="type">URL_OrderList</span> + <span class="string">"/\(type)/\(PageCount)"</span> + <span class="string">"/\(refreshStatus[currentIndex].page).json"</span></div><div class="line">        <span class="keyword">let</span> request = <span class="type">PYNetWorkTools</span>.<span class="type">GET</span>(url, hudType: .<span class="type">None</span>, failer: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (failerTuples) <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">self</span> != <span class="literal">nil</span> <span class="keyword">else</span>&#123; <span class="keyword">return</span> &#125;</div><div class="line">            <span class="keyword">self</span>?.loadFailer(failerTuples)      <span class="comment">// 加载失败的方法</span></div><div class="line">        &#125;) &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] (response, jsonResult) <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">self</span> != <span class="literal">nil</span> <span class="keyword">else</span>&#123; <span class="keyword">return</span> &#125;</div><div class="line">            <span class="keyword">self</span>?.tableView.hiddenNoNetPlace()</div><div class="line">            <span class="keyword">let</span> array = <span class="type">PYOrderListModel</span>.modelArray(jsonResult)</div><div class="line">            <span class="keyword">if</span> isRefresh &#123;</div><div class="line">                <span class="keyword">self</span>?.totalArray[indexItem] = array</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">self</span>?.totalArray[indexItem] += array</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">self</span>?.loadSuccess(array.<span class="built_in">count</span> &lt; <span class="type">PageCount</span>)      <span class="comment">// 加载成功的方法，并传递一个是否还有更多数据的返回值</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> request != <span class="literal">nil</span> &#123;</div><div class="line">            requests.append(request!)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上这些代码就可以实现上述所有的功能，怎么样，是不是很有魅力呢？实例中使用了<code>Refreshable</code>协议，这套协议可以用在<code>UIViewController</code>和<code>UITableViewController</code>中，其中的<code>refreshTable</code>就是为了适配<code>UIViewController</code>所增加的一个属性，否则连这个属性都不用写了。</p>
<h2 id="代码中能看到的协议中定义的内容如下"><a href="#代码中能看到的协议中定义的内容如下" class="headerlink" title="代码中能看到的协议中定义的内容如下"></a>代码中能看到的协议中定义的内容如下</h2><ul>
<li><p>属性</p>
<ul>
<li>refreshStatus</li>
<li>currentInidex</li>
<li>refreshTable</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>refreshData(isRefresh: Bool)</li>
<li>setupRefreshHeader()</li>
<li>setupRefreshFooter()</li>
<li>loadFailer(failerTuples: FailerTuples)</li>
<li>loadSuccess(noMoreData: Bool?)</li>
</ul>
</li>
</ul>
<h2 id="让我们先看看Refreshable这个协议里是怎么写的"><a href="#让我们先看看Refreshable这个协议里是怎么写的" class="headerlink" title="让我们先看看Refreshable这个协议里是怎么写的"></a>让我们先看看<code>Refreshable</code>这个协议里是怎么写的</h2><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">///  刷新协议</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Refreshable</span> </span>&#123;</div><div class="line">    <span class="comment">///  刷新数据的方法，必须实现，调用这个方法来执行下拉刷新和上拉加载</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">///  - parameter isRefresh: 是否是下拉刷新</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">refreshData</span><span class="params">(isRefresh: Bool)</span></span></div><div class="line">    </div><div class="line">    <span class="comment">/// 刷新状态的四个参数，分别是，当前页码，是否正在加载中，是否没有更多数据了，没有更多数据的footer显示文字</span></div><div class="line">    <span class="keyword">var</span> refreshStatus: [(page: <span class="type">Int</span>, isLoading: <span class="type">Bool</span>, noMoreData: <span class="type">Bool</span>, noMoreTitle: <span class="type">String</span>)] &#123;<span class="keyword">set</span> <span class="keyword">get</span>&#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 当前数据源的索引号</span></div><div class="line">    <span class="keyword">var</span> currentIndex: <span class="type">Int</span> &#123;<span class="keyword">set</span> <span class="keyword">get</span>&#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 需要处理的tableView</span></div><div class="line">    <span class="keyword">var</span> refreshTable: <span class="type">UITableView</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MARK: - 遵守这个协议的是控制器</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Refreshable</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">///  加载数据失败调用此方法</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">///  - parameter failerTuples: 失败原因</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">loadFailer</span><span class="params">(failerTuples: <span class="params">(type: NetFailerType, desc: String?)</span></span></span>?) &#123;</div><div class="line">        refreshStatus[currentIndex].page -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> refreshStatus[currentIndex].page &lt; <span class="number">0</span> &#123;</div><div class="line">            refreshStatus[currentIndex].page = <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        refreshStatus[currentIndex].isLoading = <span class="literal">false</span></div><div class="line">        refreshFooter()</div><div class="line">        <span class="keyword">if</span> refreshTable.mj_header != <span class="literal">nil</span> &#123;</div><div class="line">            refreshTable.mj_header.endRefreshing()</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> failerTuples?.type == <span class="type">NetFailerType</span>.<span class="type">NoNet</span> &#123;</div><div class="line">            <span class="keyword">if</span> refreshTable.visibleCells.isEmpty &#123;</div><div class="line">                refreshTable.showNoNetPlace(&#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">                    <span class="keyword">guard</span> <span class="keyword">self</span> != <span class="literal">nil</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">                    <span class="keyword">self</span>?.refreshData(<span class="literal">true</span>)</div><div class="line">                    &#125;)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                showToast(failerTuples?.type.rawValue ?? <span class="string">""</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        refreshTable.reloadData()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">///  加载数据成功调用此方法</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">///  - parameter noMoreData: 是否没有更多数据了</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">loadSuccess</span><span class="params">(noMoreData: Bool?)</span></span> &#123;</div><div class="line">        refreshStatus[currentIndex].isLoading = <span class="literal">false</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> noMoreData = noMoreData <span class="keyword">where</span> refreshTable.mj_footer != <span class="literal">nil</span> &#123;</div><div class="line">            refreshStatus[currentIndex].noMoreData = noMoreData</div><div class="line">            refreshTable.mj_footer.hidden = <span class="literal">false</span></div><div class="line">            refreshFooter()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> refreshTable.mj_header != <span class="literal">nil</span> &#123;</div><div class="line">            refreshTable.mj_header.endRefreshing()</div><div class="line">        &#125;</div><div class="line">        refreshTable.reloadData()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">///  初始化下拉刷新控件</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupRefreshHeader</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> header = <span class="type">MJRefreshNormalHeader</span> &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">self</span> != <span class="literal">nil</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">            <span class="keyword">self</span>?.refreshTable.mj_footer.resetNoMoreData()</div><div class="line">            <span class="keyword">self</span>?.refreshStatus[<span class="keyword">self</span>!.currentIndex].page = <span class="number">1</span></div><div class="line">            <span class="keyword">self</span>?.refreshData(<span class="literal">true</span>)</div><div class="line">            <span class="keyword">self</span>?.refreshStatus[<span class="keyword">self</span>!.currentIndex].isLoading = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">        refreshTable.mj_header = header</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">///  初始化上拉加载控件</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupRefreshFooter</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> footer = <span class="type">MJRefreshBackStateFooter</span> &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> <span class="keyword">self</span> != <span class="literal">nil</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">            <span class="keyword">self</span>?.refreshStatus[<span class="keyword">self</span>!.currentIndex].page += <span class="number">1</span></div><div class="line">            <span class="keyword">self</span>?.refreshData(<span class="literal">false</span>)</div><div class="line">            <span class="keyword">self</span>?.refreshStatus[<span class="keyword">self</span>!.currentIndex].isLoading = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">        footer.hidden = <span class="literal">true</span></div><div class="line">        refreshTable.mj_footer = footer</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">///  刷新上拉加载控件，用来重置上拉刷新控件状态，控制能够刷新以及显示类型</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">refreshFooter</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> refreshTable.mj_footer != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">if</span> refreshStatus[currentIndex].noMoreData &#123;</div><div class="line">                refreshTable.mj_footer.endRefreshingWithNoMoreData()</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                refreshTable.mj_footer.endRefreshing()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个协议简洁明了，没有一句废话。就把众多需要的功能及注意点都涵盖了。该协议具有以下特点。</p>
<ul>
<li>支持<code>UITableViewController</code>以及<code>UIViewcontroller</code>的刷新处理。</li>
<li>支持多数据源的切换加载。</li>
</ul>
<p>这两个特性已经涵盖了日常开发中常见的所有情况。当然你也可以只添加上拉加载，不添加下拉刷新功能，总之，这些都随便。</p>
<blockquote>
<p><a href="https://github.com/GeekerHua/Refreshable" target="_blank" rel="external">源码在这</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在app的开发中，出现最多的一个情况就是显示一个列表来展示数据，就像刷微博一样，要能够上拉加载更多，下拉进行刷新。但在实际开发过程中，需要考虑的情况会更多。我们使用&lt;code&gt;header&lt;/code&gt;来表示下拉刷新控件，使用&lt;code&gt;foote
    
    </summary>
    
      <category term="Swift" scheme="blog.geekerhua.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="blog.geekerhua.com/tags/Swift/"/>
    
      <category term="protocal" scheme="blog.geekerhua.com/tags/protocal/"/>
    
  </entry>
  
  <entry>
    <title>Git与Git工作流</title>
    <link href="blog.geekerhua.com/2016/06/02/Git_workflow/"/>
    <id>blog.geekerhua.com/2016/06/02/Git_workflow/</id>
    <published>2016-06-02T10:57:21.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-基础用法"><a href="#Git-基础用法" class="headerlink" title="Git 基础用法"></a>Git 基础用法</h1><p>SVN与Git（集中式VS分布式）</p>
<ul>
<li>集中式</li>
</ul>
<p><img src="http://7xtibb.com2.z0.glb.qiniucdn.com/2016-06-06-Git_集中式.jpeg" alt=""></p>
<ul>
<li>分布式</li>
</ul>
<p><img src="http://7xtibb.com2.z0.glb.qiniucdn.com/2016-06-06-Git_分布式.jpeg" alt=""></p>
<h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><blockquote>
<p>电脑中能够看到的目录就是工作区。</p>
</blockquote>
<h4 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h4><blockquote>
<p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
</blockquote>
<ul>
<li>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫HEAD。</li>
</ul>
<p><img src="http://7xtibb.com2.z0.glb.qiniucdn.com/2016-06-06-Git_partition_map.jpeg" alt=""></p>
<ul>
<li>git add -&gt; 将变化提交到了暂存区</li>
<li>git commit -&gt; 将暂存区的所有修改都提交到分支，并清空暂存区</li>
</ul>
<h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ git config –global user.name “姓名”</td>
<td>告诉git你是谁</td>
</tr>
<tr>
<td>$ git config –global user.email “xxx@qq.com”</td>
<td>告诉git怎么联系你</td>
</tr>
<tr>
<td>$ git config -l</td>
<td>查看配置信息</td>
</tr>
</tbody>
</table>
<h3 id="初始化代码仓库"><a href="#初始化代码仓库" class="headerlink" title="初始化代码仓库"></a>初始化代码仓库</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ git commit –amend</td>
<td>修改最后一次提交的注释</td>
</tr>
<tr>
<td>$ git init –bare</td>
<td>初始化空白的代码仓库，协同开发使用</td>
</tr>
<tr>
<td>$ git add . –all</td>
<td>将所有变化添加到暂存区</td>
</tr>
<tr>
<td>$ git commit -m “注释”</td>
<td>将暂存区内容提交至代码库</td>
</tr>
<tr>
<td>$ git init</td>
<td>初始化代码库</td>
</tr>
</tbody>
</table>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ git status</td>
<td>查看所有文件状态</td>
</tr>
<tr>
<td>$ git status 文件名</td>
<td>查看指定文件的状态</td>
</tr>
<tr>
<td>$ git log</td>
<td>查看版本库日志(按字母 q 可以退出)</td>
</tr>
<tr>
<td>$ git log 文件名</td>
<td>查看指定文件的修订记录</td>
</tr>
</tbody>
</table>
<h3 id="版本回撤"><a href="#版本回撤" class="headerlink" title="版本回撤"></a>版本回撤</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ git reset –hard HEAD^</td>
<td>回撤到上一个版本</td>
</tr>
<tr>
<td>$ git reset –hard HEAD^^</td>
<td>回撤到上上一个版本</td>
</tr>
<tr>
<td>$ git reset –hard 版本号(前6位)</td>
<td>切换到任意版本</td>
</tr>
<tr>
<td>$ git checkout 文件名</td>
<td>撤销某一个文件当前的修改(恢复到最近一次记录点状态)</td>
</tr>
<tr>
<td>$ git reflog</td>
<td>查看分支引用记录，能够查阅所有的版本号</td>
</tr>
</tbody>
</table>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ git branch</td>
<td>查看本地分支</td>
</tr>
<tr>
<td>$ git branch -r</td>
<td>查看远程分支</td>
</tr>
<tr>
<td>$ git branch [name]</td>
<td>创建本地分支(注意不会自动切换分支)</td>
</tr>
<tr>
<td>$ git checkout [name]</td>
<td>切换分支</td>
</tr>
<tr>
<td>$ git checkout -b [name]</td>
<td>创建新分支并立即切换到新分支</td>
</tr>
<tr>
<td>$ git branch -d [name]</td>
<td>只能删除已经合并过的分支<code>没有合并的分支不能删除,如果要强行删除分支，可以使用 -D 选项</code></td>
</tr>
<tr>
<td>$ git merge [name]</td>
<td>合并分支</td>
</tr>
<tr>
<td>$ git push origin [name]</td>
<td>创建远程分支<code>本质上是将本地的分支 push 到远程</code></td>
</tr>
</tbody>
</table>
<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ git pull</td>
<td>将远程代码库的变化更新到本地</td>
</tr>
<tr>
<td>$ git push</td>
<td>将本地修改内容推送到远程代码仓库</td>
</tr>
<tr>
<td>$ git clone url</td>
<td>将远程代码库克隆到本地</td>
</tr>
</tbody>
</table>
<blockquote>
<p>两篇入门教程，自行学习进修<br><a href="http://backlogtool.com/git-guide/cn/intro/intro1_1.html" target="_blank" rel="external">猴子都能懂的Git入门</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></p>
</blockquote>
<h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a><a href="http://blog.jobbole.com/76843/" target="_blank" rel="external">Git工作流</a></h2><blockquote>
<p>如何有效的进行项目流程管理和高效的开发协同。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git_workflow.png" alt=""></p>
<h3 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a><a href="http://blog.jobbole.com/76847/" target="_blank" rel="external">集中式工作流</a></h3><blockquote>
<p>使用过SVN与Subversion这类集中式版本控制系统的人刚刚转到分布式版本控制可能会很不熟悉，但Git也能做到像SVN一样的集中式版本控制，即以中央仓库作为项目所有修改的单点实体。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflow-svn.png" alt=""></p>
<h4 id="对比SVN与Git对比进行集中式版本控制"><a href="#对比SVN与Git对比进行集中式版本控制" class="headerlink" title="对比SVN与Git对比进行集中式版本控制"></a>对比SVN与Git对比进行集中式版本控制</h4><ul>
<li>SVN缺省开发分支叫<code>trunk</code>,git叫<code>master</code></li>
<li>SVN的<code>commit</code>操作相当于git的<code>push</code>操作</li>
<li>SVN的<code>update</code>操作相当于git的<code>pull</code>操作</li>
</ul>
<p>但这样的工作流并没有突出git的优势</p>
<h3 id="功能分支工作流"><a href="#功能分支工作流" class="headerlink" title="功能分支工作流"></a><a href="http://blog.jobbole.com/76857/" target="_blank" rel="external">功能分支工作流</a></h3><blockquote>
<p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用Pull Requests的方式讨论变更。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflow-feature_branch.png" alt=""></p>
<h4 id="功能分支工作流优点"><a href="#功能分支工作流优点" class="headerlink" title="功能分支工作流优点"></a>功能分支工作流优点</h4><ul>
<li>每个新功能开发都在一个专门的分支，而不是在master分支，不会弄乱主干分支</li>
<li>功能开发隔离使<code>pull requests工作流</code>成为可能</li>
<li>使用<code>pull requests</code>可以很好地进行<code>Code Review</code></li>
</ul>
<h3 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a><a href="http://blog.jobbole.com/76867/" target="_blank" rel="external">Gitflow工作流</a></h3><blockquote>
<p>Gitflow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构<br><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-gitflow.png" alt=""></p>
</blockquote>
<p><strong><a href="http://www.jianshu.com/p/7dddf0e9f1ef" target="_blank" rel="external">目前iOS开发大体上遵循这种工作流</a></strong><br><img src="http://upload-images.jianshu.io/upload_images/296122-5de3d3e00962f911.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Forking工作流"><a href="#Forking工作流" class="headerlink" title="Forking工作流"></a><a href="http://blog.jobbole.com/76861/" target="_blank" rel="external">Forking工作流</a></h3><blockquote>
<p>Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflow-forking.png" alt=""></p>
<ul>
<li>Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限</li>
<li>GitHub中每个代码仓库都有三个选项，分别是Star、Watch、Fork，</li>
<li><img src="quiver-image-url/F81C279EDF5AD53780259EB087CD4F84.png" alt="屏幕快照 2016-04-11 下午11.20.38.png"></li>
</ul>
<h4 id="流程如下"><a href="#流程如下" class="headerlink" title="流程如下"></a>流程如下</h4><ul>
<li>项目维护者初始化正式仓库<ul>
<li><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-forking-1.png" alt=""> </li>
</ul>
</li>
<li>开发者fork正式仓库<ul>
<li><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-forking-2.png" alt=""> </li>
</ul>
</li>
<li>开发者克隆自己fork出来的仓库<ul>
<li><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-forking-3.png" alt=""> </li>
</ul>
</li>
<li>开发者开发自己的功能<ul>
<li><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-forking-4.png" alt=""> </li>
</ul>
</li>
<li>开发者发布自己的功能<ul>
<li><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-forking-5.png" alt=""> </li>
</ul>
</li>
<li>项目维护者集成开发者的功能<ul>
<li><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-forking-6.png" alt=""> </li>
</ul>
</li>
<li>开发者和正式仓库做同步<ul>
<li><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/git-workflows-forking-7.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a><a href="http://blog.jobbole.com/76854/" target="_blank" rel="external">Pull Requests</a></h3><blockquote>
<p>Pull Requests是Bitbucket上方便开发者之间协作的功能。提供了一个用户友好的Web界面，在集成提交的变更到正式项目前可以对变更进行讨论。GitHub也有这个功能。<br>Pull Request可以和功能分支工作流、Gitflow工作流或Forking工作流一起使用。<br><img src="quiver-image-url/8E87744F9F2DAF716E5CF4E727C2A4C8.png" alt="屏幕快照 2016-04-11 下午11.21.45.png"></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/quickhack/translations/master/git-workflows-and-tutorials/images/pull-request.png" alt=""></p>
<h2 id="Commit-message-和-Change-log-编写指南"><a href="#Commit-message-和-Change-log-编写指南" class="headerlink" title="Commit message 和 Change log 编写指南"></a><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html#rd?sukey=ecafc0a7cc4a741b1e6e4fadd82915cefdf73cbbe70d0626a8bce92a8162402a53d6fb99492db71ab5fb4ae3ff50d974" target="_blank" rel="external">Commit message 和 Change log 编写指南</a></h2><blockquote>
<p>通常我们是这样提交代码的<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git commit -m <span class="string">"hello world"</span></div></pre></td></tr></table></figure></p>
<p>但这样的提交注释并没有卵用，当你log提交记录的时候，还是会看的云里雾里，更不用说是利用了。现在通用的效果比较好的Commit messag规范是<code>Angular规范</code>。</p>
</blockquote>
<h3 id="commit-message的作用"><a href="#commit-message的作用" class="headerlink" title="commit message的作用"></a>commit message的作用</h3><ul>
<li>提供更多的历史信息，方便快速浏览<blockquote>
<p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s</div></pre></td></tr></table></figure>
<ul>
<li><p>可以过滤某些commit（比如文档改动），便于快速查找信息。</p>
<blockquote>
<p>比如，下面的命令仅仅显示本次发布新增加的功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> &lt;last release&gt; HEAD --grep feature</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>可以直接从commit生成Change log。</p>
<blockquote>
<p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010603.png" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="Commit-message-的格式"><a href="#Commit-message-的格式" class="headerlink" title="Commit message 的格式"></a>Commit message 的格式</h3><blockquote>
<p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;</div><div class="line">// 空一行</div><div class="line">&lt;body&gt;</div><div class="line">// 空一行</div><div class="line">&lt;footer&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>其中，Header 是必需的，Body 和 Footer 可以省略。</p>
</blockquote>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><blockquote>
<p>type用于说明 commit 的类别，只允许使用下面7个标识。</p>
</blockquote>
<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>docs：文档（documentation）</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
<h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h5><blockquote>
<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
</blockquote>
<h5 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h5><blockquote>
<p>subject是 commit 目的的简短描述，不超过50个字符。</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</li>
<li>第一个字母小写</li>
<li>结尾不加句号（.）</li>
</ul>
</blockquote>
<h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><blockquote>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>
</blockquote>
<p><strong>有两个注意点</strong></p>
<ol>
<li>使用第一人称现在时，比如使用change而不是changed或changes。</li>
<li>应该说明代码变动的动机，以及与以前行为的对比。</li>
</ol>
<h4 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h4><h5 id="不兼容变动"><a href="#不兼容变动" class="headerlink" title="不兼容变动"></a>不兼容变动</h5><blockquote>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
</blockquote>
<h5 id="关闭-Issue"><a href="#关闭-Issue" class="headerlink" title="关闭 Issue"></a>关闭 Issue</h5><blockquote>
<p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Closes <span class="comment">#234</span></div><div class="line"></div><div class="line">Closes <span class="comment">#123, #245, #992</span></div></pre></td></tr></table></figure>
<h4 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h4><blockquote>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">revert: feat(pencil): add <span class="string">'graphiteWidth'</span> option</div><div class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</div></pre></td></tr></table></figure>
<blockquote>
<p>Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。<br>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git-基础用法&quot;&gt;&lt;a href=&quot;#Git-基础用法&quot; class=&quot;headerlink&quot; title=&quot;Git 基础用法&quot;&gt;&lt;/a&gt;Git 基础用法&lt;/h1&gt;&lt;p&gt;SVN与Git（集中式VS分布式）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中式&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
      <category term="工具" scheme="blog.geekerhua.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="blog.geekerhua.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>终极Shell修行大法-不得不拥有</title>
    <link href="blog.geekerhua.com/2015/12/10/Ultimate_shell/"/>
    <id>blog.geekerhua.com/2015/12/10/Ultimate_shell/</id>
    <published>2015-12-10T10:57:21.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a></h1><blockquote>
<p>Shell神器,OS X 不可或缺的套件管理器。<code>Homebrew</code>较之于<code>Shell</code>,好比<code>CocoaPod</code>较之于<code>Xcode</code>。这么说,<code>Homebrew</code>的定位就应该相当明确了吧！</p>
</blockquote>
<ul>
<li><p>安装:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></div></pre></td></tr></table></figure>
</li>
<li><p>卸载:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)"</span></div></pre></td></tr></table></figure>
</li>
<li><p>更新已安装的package</p>
<ul>
<li>先更新brew：$ <code>brew update</code></li>
<li>更新所有package：$ <code>brew upgarde</code></li>
</ul>
</li>
<li>Homebrew下载的package存放的路径在哪里？<ul>
<li><code>/Library/Caches/Homebrew/</code></li>
</ul>
</li>
</ul>
<p>Homebrew 可以很方便的安装需要的套件,方法如下：$ <code>brew install wget</code>。是不是很简单？</p>
<p>Homebrew 使 OS X 更完美。使用 gem 来安装 gems、用 brew 来搞定那些依赖包。</p>
<blockquote>
<p>Tips:</p>
<ul>
<li>如果安装过程中提示错误,提示先卸载,但执行卸载命令又卸载不掉,说明有曾经安装失败过,有残留。解决方式删除<code>/usr/local</code>文件夹即可。</li>
</ul>
</blockquote>
<p><img src="http://7xtibb.com2.z0.glb.qiniucdn.com/2016-06-06-Shell_Homebrew安装失败.png" alt="Shell_Homebrew安装失败"></p>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a><a href="http://baike.baidu.com/link?url=_4E-kuBinS_AItjdR3vsisJTYpRsOCav7kEUifcKfUsLGMAML6kPVKJK0tVd5tOhLP13C_BnTzI7yFHFENwiKq" target="_blank" rel="external">wget</a></h2><blockquote>
<p>wget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合。</p>
</blockquote>
<ul>
<li><code>Homebrew</code>下安装: 在安装了<code>Homebrew</code>的情况下安装wget特别简单。只需要：$ <code>brew install wget</code> 即可。如果没安装<code>Homebrew</code>建议赶紧安装。</li>
<li>正常安装(特别复杂,不建议直接安装)：<ol>
<li><a href="http://ftp.gnu.org/gnu/wget/wget-1.13.4.tar.gz" target="_blank" rel="external">http://ftp.gnu.org/gnu/wget/wget-1.13.4.tar.gz</a><br>下载源码包。这里面找到最新版本，直接下载安装就行了</li>
<li>到目录<code>cd /usr/local/src</code> 解压： tar -zxvf wget-1.13.tar.gz</li>
<li><code>./configure</code>，这个过程第一次是不成功的，然后提示你下载安装一个make,安装make后，再运行一下<code>./configure</code>。</li>
<li><code>make</code></li>
<li><code>sudo make install</code></li>
</ol>
</li>
</ul>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><blockquote>
<p>终极shell,Mac自带就有,使用<a href="http://ohmyz.sh" target="_blank" rel="external"><code>oh-my-zsh</code></a>进行配置,简单又强大.配合iTerm 2一同使用,简单又强大。</p>
<ul>
<li><a href="http://www.zhihu.com/question/20873070/answer/43230384" target="_blank" rel="external">iTerm 2 &amp;&amp; Oh My Zsh博客</a></li>
<li><a href="http://tieba.baidu.com/p/2818750493" target="_blank" rel="external">终极shell</a></li>
</ul>
</blockquote>
<p><img src="http://7xtibb.com2.z0.glb.qiniucdn.com/2016-06-06-Shell_zsh_them.png" alt="Shell_zsh_the"></p>
<ul>
<li><p>安装</p>
<ol>
<li><p>下载一个 .oh-my-zsh 配置（推荐有）</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">git clone <span class="symbol">git:</span>/<span class="regexp">/github.com/robbyrussell</span><span class="regexp">/oh-my-zsh.git ~/</span>.oh-my-zsh</div></pre></td></tr></table></figure>
</li>
<li><p>创建新配置（备份）</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">cp ~<span class="regexp">/.zshrc ~/</span>.zshrc.orig</div><div class="line">cp ~<span class="regexp">/.oh-my-zsh/templates</span><span class="regexp">/zshrc.zsh-template ~/</span>.zshrc</div></pre></td></tr></table></figure>
</li>
<li><p>把 zsh 设置成默认的 shell</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">chsh -s /bin/zsh</div></pre></td></tr></table></figure>
</li>
<li><p>重启 zsh (打开一个新的 terminal 窗口)</p>
</li>
</ol>
</li>
<li><p>配置</p>
<ul>
<li>主题：agnoster</li>
<li><p>字体：Powerline （把 iTerm 2 的设置里的 Profile 中的 Text 选项卡中里的 Regular Font 和 Non-ASCII Font 的字体都设置成 Powerline 的字体。）</p>
<ul>
<li><p>推荐使用 14pt Meslo LG S DZ Regular for Powerline </p>
<blockquote>
<ul>
<li><a href="https://powerline.readthedocs.org/en/master/" target="_blank" rel="external">Powerline — Powerline beta documentation</a></li>
<li><a href="https://github.com/powerline/fonts" target="_blank" rel="external">powerline/fonts · GitHub</a></li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>设置命令正确绿色高亮,错误红色高亮</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">git clone <span class="symbol">git:</span>/<span class="regexp">/github.com/jimmijj</span><span class="regexp">/zsh-syntax-highlighting ~/</span>.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</div></pre></td></tr></table></figure>
</li>
<li><p>然后在~/.zshrc中插件那添加 </p>
<ul>
<li><code>plugins=(zsh-syntax-highlighting)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>加强zsh的补全功能实现tab自动纠错</p>
<ul>
<li><p>把这两句话添加到oh-my-zsh/lib/completion.zsh  (末尾)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">zstyle <span class="string">':completion:incremental:*'</span> completer _complete _correct</div><div class="line">zstyle <span class="string">':completion:*'</span> completer _complete _prefix _correct _prefix _match _approximate</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="zsh-好处"><a href="#zsh-好处" class="headerlink" title="zsh 好处"></a>zsh 好处</h3><ol>
<li><p>zsh 可以<strong>补全参数</strong><br>当你敲指令敲到一般的时候，不必在虚拟终端下Ctrl_Shift_T 打开一个新标签看手册了，只需要一个<tab>，zsh 会为你列出所有符合你已经输入部分的参数，其后跟着参数说明，你需要的只是看下其后的说明，然后选中你需要的参数按下回车键。视频中我们差一点就用纯tab 完成了一条dd 指令。</tab></p>
</li>
<li><p>zsh 的<strong>参数补全是智能补全</strong><br>简单的例子：<br>当你输入ls 指令按下<tab> 的时候，zsh 会列出目录下所有的文件并让你交互式处理。<br>当你输入unzip 指令要求补全的时候，zsh 只会列出zip 文件<br>当你输入kill 指令要求补全的时候，zsh 会列出所有符合要求的进程并自动把参数转换为PID。<br>当你输入参数的一部分时（例如systemctl 的–type=,-t），zsh 会列出其后所有的可能性供你选择。</tab></p>
</li>
<li><p>zsh 可以<strong>补全路径</strong><br>当你想到你的vim 插件目录下看看的时候，你甚至连cd 都不需要输入，你要做的只是/u/s/v/vimf/p<tab><enter></enter></tab></p>
</li>
<li><p>zsh 可以<strong>不额外安装autojump 在目录中快速跳转</strong><br>安装oh-my-zsh 后，在你的plugins=() 中加入jump（事实上这个插件提供的是几个函数）。之后mark dir 标记一个目录，下次jump dir 就可以快速跳转到该目录。</p>
</li>
<li><p>zsh 可以<strong>自动纠错指令</strong><br>当你输入了错误的指令时，如果只是几个字母按错了，一个<tab> zsh 就会为你自动纠错。<br>你可以利用这个特性缩写指令，例如把systemd-analyze 变成sys-an<tab>。</tab></tab></p>
</li>
<li><p>zsh 可以<strong>预先告知你指令中的错误</strong><br>zsh 会将错误的指令显示为红色，正确的指令（或者函数、alisa）会被显示为绿色。<br>至于目录和文件，虚拟终端下，存在的文件或目录会被显示为下划线形式，tty 下则是绿色，不存在的都会被现实为普通的白色。<br>所以当你重定向&gt; file，如果file 带下划线，你会事先明白你的操作会清空一个已经存在的文件而不是重定向到新文件。这个特性对于新手来说是非常有用的。</p>
</li>
<li><p>zsh 可以<strong>补全环境变量</strong><br>环境变量大多数都比较难记，而且大小写都有，感到很困难？zsh 中一个tab 为你列出所有符合期望的环境变量，你做的只是按上下左右键挑选一个即可。</p>
</li>
<li><p>zsh 有<strong>多重定向</strong>的功能<br>简单的例子：<br>当你指令后跟着”&gt;/dev/null &gt;1 &gt;2” 的时候，zsh 明白你的意思是将stdout 分别重定向到三个流，但是bash 就无法如此。<br>而当你后跟”&gt;/dev/null 2&gt;&amp;1 &amp;” 的时候，zsh 明白你的意思是将stdout 和stderr 都重定向到一个流。<br>zsh 会推断你的意图，如果你是perl 用户，你会很熟悉这种行为。</p>
</li>
<li><p>zsh 可以<strong>提示通配符的作用范围</strong><br>不知道有多少人有过”rm -rf dir/&lt;空格&gt;<em> “ 的悲剧——你想清空目录其下的文件并保留目录，结果删除了当前目录下所有的文件。<br>zsh 会将被通配符作用的参数显示为深蓝色，当你手贱在”dir/“ 和”</em>“ 之间敲了一个回车的时候，”/dir” 会立刻变白，你会明白我的通配符无法作用于”dir/“，从而预料到这条指令可能造成什么后果。<br>事实上：zsh 也有着防手贱的能力，当你rm -rf dir/* 的时候，即使带着-f 参数，zsh 仍然会询问你是否真的想这样做（但是不要认为zsh 总会这样）。</p>
</li>
<li><p>zsh 可以<strong>有区分的提示指令历史</strong><br>在你的.zshrc 的plugins=() 中添加history 插件，简单的例子：<br>在目录A 下输入ls 按上箭头，zsh 会提示你所有在目录A 下执行的ls 指令——zsh 绝对不会补全一个在其他目录下指令的ls 指令的，因为zsh 明白即使补全了，这条指令也对你毫无用处。<br>当然这样做有好有坏，如果你不喜欢这个特性，不要启用history 插件。</p>
</li>
<li><p>zsh 内置了大量的<strong>命令提示符样式</strong><br>.zshrc 的plugins=() 中添加theme 插件，敲theme 指令回车可以随机选择，后跟参数可以选择指定的样式，例如theme gen<tab><enter> 会切换到gentoo 样式，这也是新手美化过程中非常痛苦的一环。</enter></tab></p>
</li>
<li><p>zsh <strong>可以alisa 参数</strong><br>相对于其他shell 的alisa 指令，zsh 中你可以为参数alisa 一个缩写！</p>
</li>
<li><p>zsh <strong>脚本的语法更加顺手</strong><br>简单的例子：bash 中设置PATH，你需要PATH 后跟长长的一串，然而zsh 中可以写成<br>PATH=(<br>dir1<br>dir2<br>dir3<br>……<br>)</p>
</li>
<li><p>zsh 的<strong>配置非常省心</strong><br>安装oh-my-zsh 后，配置都已经被继承，你可以很简单的配置好一个舒服的zsh——我的.zshrc 除去成片的alisa 之外，有效配置只有十几行。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Homebrew&quot;&gt;&lt;a href=&quot;#Homebrew&quot; class=&quot;headerlink&quot; title=&quot;Homebrew&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://brew.sh/index_zh-cn.html&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="Linux" scheme="blog.geekerhua.com/categories/Linux/"/>
    
    
      <category term="Shell" scheme="blog.geekerhua.com/tags/Shell/"/>
    
      <category term="Linux" scheme="blog.geekerhua.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>从面试官的角度谈iOS面试</title>
    <link href="blog.geekerhua.com/2015/12/07/iOS_interview/"/>
    <id>blog.geekerhua.com/2015/12/07/iOS_interview/</id>
    <published>2015-12-07T10:57:21.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本来,这篇博文应该在大约1个月前发布的,无奈项目无节制的加班剥夺了我的时间,一拖再拖,直到有一天我开始管理我的时间,才有功夫把它写完,发布出来。 </p>
</blockquote>
<p>没成想、距上次去面试已经过了半年有余了，感觉时间过得好快，印象中只有周一、周五，就连周六、周日也过得飞快。不经意间由于内在和外在的因素，招聘新的iOS成员的重任落到了我的头上。本文将通过完整的情景介绍在招聘官的立场上的面试。</p>
<h4 id="首先介绍下这次招聘的前提"><a href="#首先介绍下这次招聘的前提" class="headerlink" title="首先介绍下这次招聘的前提"></a>首先介绍下这次招聘的前提</h4><p>由于公司业务需要，需要招聘一名中级、一名高级iOS工程师外派到青岛工作。说实话，这个工作的优点是可以拿着北京的高工资、享受海尔的生活。缺点就是对很多打算留在北京或者已经安家的人、甚至是刚刚来到北京想要闯荡一番的人来说，可能是万万无法接受的。至于得与失，每个人的评判标准都不一样。面试要求无非就是能干活，其实领导什么也没交代，只是说要技术好的（很感谢被领导信任。PS:没有目地的招聘就是自欺欺人）。</p>
<p>不到两天的时间里，我先后面试了11个人，在此之前是从来没有去面过别人的，倒是被别人面了10多次，两个10多次，也算是打平了。</p>
<p>####说说我对于招聘的理解：</p>
<ul>
<li>首先，公司肯定是想花更少的钱来招到技术实力更好的人才。</li>
<li>其次，不同的公司由于各自情况不同，对人才的看法与重视程度是不同的，比如我们是做外包的，对实力的要求是能干活，不需要别人带，尽量不会给别人留下坑。</li>
<li>很多人想来到公司有人带、能够学习、能够进步。其实如果自己积极向上，就算没人带，自己依然能够学习、能够进步，技术水平的进步更重要的是看人自身思想和学习能力。没有一个公司想花成本招来需要人带、需要学习的程序员。</li>
<li>永远不要畏惧你的面试官、很多东西他不问你，可能是它也不知道、实质是都不知道问什么。</li>
</ul>
<p>####再来说说面试注意事项：</p>
<ul>
<li>一定要带一份简历,哪怕是知道,目标公司可能会帮你打印一份简历,如果没打印呢！拿什么介绍你自己呢？光靠一张嘴很多东西是说不出来的,更何况不带简历,怎么突出你的优势呢,让面试官问你什么问题呢。</li>
<li>准时,这个不解释,不准时的话,可能直接pass掉,如果不能及时来,提前通知招聘方。</li>
<li>可以自信,不能自大。自信会让自己说话有底气,面试官听了也舒服,会加分。但相反自大会让面试官产生厌恶,会给面试官一种目空一切,目中无人的感觉,直接结果就是pass。</li>
</ul>
<p>####再聊聊项目<br>项目可大可小,做的工作可多可少,协助别人写了一个页面也叫做过,但毕竟差的太多了不是？</p>
<ul>
<li>项目经验,一定要写上自己做了哪些模块,尽量写有价值的东西,否则,面试官又不知道这个项目有什么技术难点,又不知道你到底写了哪些模块,根本就没法评估你在这个项目中的付出和重要程度。</li>
<li>一定要在项目中突出自己的优势,要用数据去展示自己的价值。比如说<code>进行代码重构,将3000行的代码拆分到3个控制器中,保证了可维护性</code>。</li>
<li>项目贵在精而不在多,试想一下,如果干了很多项目,每个项目时间都很短,相应的在技术上肯定不会有太多出色的地方,大多是流水账,否则也不会这么快就完成了。因此,只需要详细描述两个自己权重最高的项目即可,在这两个项目中,可以用更多的篇幅来阐述自己的能力以及贡献,更加具有说服力。</li>
</ul>
<p>####最后聊聊技术</p>
<ul>
<li>除非面试的公司从来都没有过iOS开发人员,否则公司必然会有一套自己的框架体系,可能特别简单,几个分类就OK了,也可能特别复杂,面面俱到,能够应付各种使用环境。这些本来就有的东西,可能已经非常完善了,拥有多样性的Api、封装完好、良好的注释,使用起来方便顺手,上手难度很低。也有可能就是从哪个已有的项目中抽出来的,并没没有及时进行封装处理,也没有完好的注释,甚至于只适用于当时的语境,没有预留足够的接口,每次使用都需要去修改里边的东西。这些都是资源。面试官其实更希望你能够聊聊这些,聊一聊都有哪些这样的框架,怎么学习这些框架,甚至是自己封装这些框架的。</li>
<li>有一个自己的技术博客确实是一个加分项,要知道,自己会和能说出来是完全不同的两个水平。如果你能够清晰的在自己的技术博客中表达出来,想必做起来应该也是十分得心应手的。况且技术博客可以从另一个角度证明自己的技术水准甚至是工作经验。</li>
<li>相信自己的技术,没有人能够什么都会,同样面试官也是,因此,对于会的东西大胆去说,对于不会的东西,也就可以大胆的去学习,不要害怕自己不会。因为会的越多,不会的也就越多。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本来,这篇博文应该在大约1个月前发布的,无奈项目无节制的加班剥夺了我的时间,一拖再拖,直到有一天我开始管理我的时间,才有功夫把它写完,发布出来。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没成想、距上次去面试已经过了半年有余了，感觉时间过得好快，
    
    </summary>
    
      <category term="Other" scheme="blog.geekerhua.com/categories/Other/"/>
    
    
      <category term="interview" scheme="blog.geekerhua.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>多读书,读好书</title>
    <link href="blog.geekerhua.com/2015/11/04/Read_more_book/"/>
    <id>blog.geekerhua.com/2015/11/04/Read_more_book/</id>
    <published>2015-11-04T10:57:21.000Z</published>
    <updated>2017-02-13T05:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015年11月01日京东进行双十一活动,其中在11月01日和02日两天全场自营图书满200减100,这相当于在京东正版的优惠图书价格上打了5折,于是乎淘书活动开始了。在经历筛选、缺货、预定、购买的一些列过程后,终于买下了以下几本书。</p>
<ul>
<li>MacTalk人生元编程</li>
<li>重构 改善既有代码的设计</li>
<li>设计模式：可复用面向对象软件的基础</li>
<li>树莓派 Raspberry Pi 实战指南：手把手教你掌握100个精彩案例</li>
<li>数字匠人：树莓派Python编程指南</li>
</ul>
<p>第二天,借用同事的账号又买了几本书</p>
<ul>
<li>算法导论 原书第3版</li>
<li>React：引领未来的用户界面开发框架 </li>
<li>鸟哥的Linux私房菜 （基础学习篇 第三版）</li>
</ul>
<p>至此一共买了8本书,打完折,一共花了￥230左右,大喜啊！至少能看个几年了,可以好好研究研究,镀金一下。接下来就是一边看书,一边写读书笔记了。</p>
<p>再来说说读书,一个朋友和我说,<code>每年读5本书算是及格,每年读10本书算是优秀,不读书、又不会数据结构、更不会算法、设计模式,算什么程序员。</code>对此我只能说呵呵,是啊！能够在工作中静下心来读书又有多少人呢,软件本身就是一个高工资的行业,拿着高薪水,又有多少人能够安心下来好好读书呢。</p>
<p>再来说说为什么要读书,不读书那你干什么呢？打游戏？游戏能提升什么呢？除了浪费时间,浪费精力,也只能图得一时痛快罢了。有朋友们在聊天,总结起来有以下几点。</p>
<ul>
<li>自己公司资金链断了</li>
<li>没钱了,公司要倒闭了</li>
<li>3个人裁了两个,少发年终奖</li>
<li>听说xx公司也停止社会招聘了</li>
<li>某某公司一个部门一个部门的裁人</li>
<li>互联网寒冬来了,iOS供大于求</li>
</ul>
<p>而更多地人则说工作是越来越难找了,大家都人心惶惶的,有人甚至提议学PHP,因为PHP人才比较紧缺,薪水也比以前涨了很多,和iOS有的比了。总之不管怎样,提升自身的能力真的是重中之重。自己有了实力还怕没有工作？还怕没饭吃？</p>
<p><code>多读书,读好书</code></p>
<p>我会沿着我的步伐,成长！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年11月01日京东进行双十一活动,其中在11月01日和02日两天全场自营图书满200减100,这相当于在京东正版的优惠图书价格上打了5折,于是乎淘书活动开始了。在经历筛选、缺货、预定、购买的一些列过程后,终于买下了以下几本书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MacTal
    
    </summary>
    
      <category term="Reading" scheme="blog.geekerhua.com/categories/Reading/"/>
    
    
      <category term="other" scheme="blog.geekerhua.com/tags/other/"/>
    
  </entry>
  
</feed>
